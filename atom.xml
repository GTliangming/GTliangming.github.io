<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小明同学的博客</title>
  
  
  <link href="http://gtliangming.github.io/atom.xml" rel="self"/>
  
  <link href="http://gtliangming.github.io/"/>
  <updated>2020-12-09T05:56:32.770Z</updated>
  <id>http://gtliangming.github.io/</id>
  
  <author>
    <name>Bruce Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins的安装与配置</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jx80002fanm1brihuq4/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jx80002fanm1brihuq4/</id>
    <published>2020-12-09T05:52:52.000Z</published>
    <updated>2020-12-09T05:56:32.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是jenkins"><a href="#一、什么是jenkins" class="headerlink" title="一、什么是jenkins"></a>一、什么是jenkins</h1><p>​    Jenkins是一个开源软件项目，是<code>基于java开发</code>的一种<a href="https://aws.amazon.com/cn/devops/continuous-integration/">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><blockquote><p>为什么要使用jenkins这类持续集成工具（优势）</p><p>1、提高开发人员的工作效率</p><p>​    持续集成可将开发人员从手动任务中解放出来，并且鼓励有助于减少发布到客户环境中的错误和缺陷数量的行为，从而提高团队的工作效率。    </p><p>2、更快发现并解决缺陷</p><p>​    通过更频繁的测试，您的团队可以在缺陷稍后变成大问题前发现并解决这些缺陷。</p><p>3、更快交付更新</p><p>​    持续集成有助于您的团队更快、更频繁地向客户交付更新。</p></blockquote><p>常见的持续集成工具还有： <strong>TeamCity</strong> 、<strong>Travis CI</strong>、<strong>Go CD</strong> 等</p><h1 id="二、jenkins部署流程"><a href="#二、jenkins部署流程" class="headerlink" title="二、jenkins部署流程"></a>二、jenkins部署流程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201204175311.png"></p><h1 id="三、安装jenkins"><a href="#三、安装jenkins" class="headerlink" title="三、安装jenkins"></a>三、安装jenkins</h1><h4 id="1、安装java环境"><a href="#1、安装java环境" class="headerlink" title="1、安装java环境"></a><strong>1、安装java环境</strong></h4><p>​    主要是因为jenkins是基于java环境的 </p><ul><li>准备工作。需要为 Jenkins 安装一个 Java 运行环境 <code>yum search openjdk</code></li><li>安装合适的jdk 例如 <code>yum install java-1.8.0-openjdk</code></li><li>配置环境变量</li><li>命令查看 <code>java -version</code> 是否安装成功</li></ul><h4 id="2、jenkins的安装"><a href="#2、jenkins的安装" class="headerlink" title="2、jenkins的安装"></a><strong>2、jenkins的安装</strong></h4><p>​    官方网站：<a href="https://www.jenkins.io/zh/">https://www.jenkins.io/zh/</a></p><p>​    安装文档：<a href="https://www.jenkins.io/doc/book/installing/linux/#red-hat-centos">https://www.jenkins.io/doc/book/installing/linux/#red-hat-centos</a>(此次安装的是基于Centos)</p><pre><code>&gt; sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo &gt;&gt; sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key  &gt;&gt; sudo yum install jenkins &gt;&gt; :(  可能会有报错(很大可能会有报错^__^)  百度都可以解决</code></pre><h4 id="3、-启动-关闭-Jenkins"><a href="#3、-启动-关闭-Jenkins" class="headerlink" title="3、 启动/关闭 Jenkins"></a><strong>3、 启动/关闭 Jenkins</strong></h4><p><code>sudo service jenkins start/stop/restart  //显然，最后的参数分别对应启动、关闭、重启操作</code></p><p> <code>sudo chkconfig jenkins on</code></p><p>上面的操作创建了一个叫做 jenkins 的用户来运行这个服务（也就是 Jenkins 服务）、将Jenkins 将在开机时作为守护进程启动，避免了每次都需要自行启动jenkins</p><h4 id="4、配置防火墙"><a href="#4、配置防火墙" class="headerlink" title="4、配置防火墙"></a><strong>4、配置防火墙</strong></h4><ul><li><p>查看jenkins状态 <code>systemctl status jenkins</code></p></li><li><p>查看防火墙状态 <code>systemctl status firewalld</code></p></li><li><p>查看端口情况 <code>firewall-cmd --list-ports</code></p><blockquote><p>Jenkins 默认端口8080 需要在安全组配置中打开 </p></blockquote></li></ul><h4 id="5、查看jenkins"><a href="#5、查看jenkins" class="headerlink" title="5、查看jenkins"></a><strong>5、查看jenkins</strong></h4><p>​    本地：浏览器打开<code>localhost:8080</code></p><p>​    自定义服务器：浏览器打开 <code>服务器ip:8080</code></p><p>首次打开需要密码：密码在<code>/var/lib/jenkins/secrets/initialAdminPassword</code>内可以查看到</p><p>输入密码后稍等片刻就可看到jenkins的界面了</p><h1 id="四、自定义配置"><a href="#四、自定义配置" class="headerlink" title="四、自定义配置"></a>四、自定义配置</h1><h4 id="1、自定义jenkins端口"><a href="#1、自定义jenkins端口" class="headerlink" title="1、自定义jenkins端口"></a><strong>1、自定义jenkins端口</strong></h4><ul><li><p>终端打开<code>vim /etc/sysconfig/jenkins</code> 修改<code>JENKINS_PORT=&quot;xxxx&quot;</code></p></li><li><p>jenkins管理界面修改</p><p><strong>系统管理—&gt;系统设置—&gt;管理监控配置—&gt;JenKins Location</strong> 修改和刚才一致的端口号，否则会报错反向代理设置有误</p></li><li><p>然后重启jenkins:<code>systemctl restart jenkins</code></p></li></ul><h4 id="2、安装插件"><a href="#2、安装插件" class="headerlink" title="2、安装插件"></a><strong>2、安装插件</strong></h4><ul><li>1、打开登陆Jenkins，点击Manage Jenkins</li><li>2、找到Plugin Manager，点击进入</li><li>3、打开Available点击，输入需要的插件名称，</li><li>4、勾选后 点击<code>install without restart </code> 下载并重启jenkins</li></ul><h4 id="3、jenkins汉化-🤷‍♂️-🤷‍♂️-🤷‍♂️-🤷‍♂️-🤷‍♂️"><a href="#3、jenkins汉化-🤷‍♂️-🤷‍♂️-🤷‍♂️-🤷‍♂️-🤷‍♂️" class="headerlink" title="**3、jenkins汉化 **   🤷‍♂️ 🤷‍♂️ 🤷‍♂️ 🤷‍♂️ 🤷‍♂️"></a>**3、jenkins汉化 **   🤷‍♂️ 🤷‍♂️ 🤷‍♂️ 🤷‍♂️ 🤷‍♂️</h4><p>​    对于一个程序员，虽然说英文是必须的，但是有中文还是更方便的，话不多说，来安装插件</p><ul><li>1、打开登陆Jenkins，点击Manage Jenkins</li><li>2、找到Plugin Manager，点击进入</li><li>3、打开Available点击，输入需要的插件名称，查找插件 <strong>Localization: Chinese (Simplified)</strong> 、<strong>locale</strong></li><li>4、勾选后 点击<code>install without restart </code> 下载并重启jenkins</li><li>5 、找到configure Sytem</li><li>6、找到locale 并设置默认语言为 <code>zh_CN</code> 并勾选下面的Ignore browser preference and force this language to all users</li><li>7、点击 Apply应用 </li><li>8、重启jenkins就可以看到汉化的界面（遗憾的是  部分汉化）</li></ul><h1 id="五、使用jenkins"><a href="#五、使用jenkins" class="headerlink" title="五、使用jenkins"></a>五、使用jenkins</h1><h3 id="1、创建任务"><a href="#1、创建任务" class="headerlink" title="1、创建任务"></a>1、创建任务</h3><p>打开jenkins控制台–&gt;选择New Item 开始创建新的任务</p><p>基本操作：先起个名   然后选择 <code>Freestyle project</code> （具体的选择那个要看自己的项目情况）</p><h3 id="2、开始配置"><a href="#2、开始配置" class="headerlink" title="2、开始配置"></a>2、开始配置</h3><ul><li><p>General 通用配置</p><p>描述：描述一下此任务的内容（可省略）</p><p>选项：</p><blockquote><ul><li><p>Discard old builds    丢弃旧的构建</p><p>选择保持构建的天数（Days to keep builds）和保持构建的最大个数（Max # of builds to keep）</p></li><li><p>GitHub project     GitHub项目构建</p></li><li><p>This build requires lockable resources   此构建需要可锁定的资源</p></li><li><p>This project is parameterized   参数化构建</p></li><li><p>Throttle builds    节流阀构建</p></li><li><p>Disable this project    禁用此项目</p></li><li><p>Execute concurrent builds if necessary  在必要的时候并发构建</p></li></ul></blockquote></li><li><p>源码管理</p><p>可以选择源码的来源（github、gitlab、svn都可以，但是都需要安装对应的插件）</p><blockquote><p>这里以github为例 gitbub插件 <code>github</code>、<code>Git Parameter</code>（支持选择分支和 Tag ）</p><p>注意：未安装插件前此处是不会有git的选项的 </p></blockquote><p>1、选择git后 配置仓库地址Repository URL</p><p>2、配置证书 Credentials（可选配置，私有仓库需要）</p><p>3、配置构建分支</p><p>4、可选构建的Tag</p></li><li><p>构建触发器（在什么情况下触发构建）</p><blockquote><ul><li>Trigger builds remotely (e.g., from scripts)     远程触发构建（例如，从脚本）</li><li>Build after other projects are built    其他项目建成后再进行构建</li><li>Build periodically   定期构建</li><li>GitHub hook trigger for GITScm polling   通过Github hook进行轮训构建</li><li>Poll SCM 轮询构建   </li></ul></blockquote><p>主要来说轮询构建（在符合时间表的规定时间来进行自动构建）</p><p>添加日程表 格式：五位 ****</p><p>1、第一个*代表分钟 取值0-59  第几分钟执行</p><p>2、第二个*代表小时 取值0-23  第几小时执行</p><p>3、第三个*代表日 取值1-31 第几日执行</p><p>4、第四个*代表月 取值1-12 第几个月执行</p><p>5、第五个*代表星期 取值0-6 每周第几天执行（周天是第一天）</p><p>例：</p><p><code>* * * * *</code> 每分钟 、 <code>H * * * *</code>每小时 、<code>/</code> 代表步长</p><p><code>H/30 * * * *</code> : 每半小时检查一次代码是否有更新，有的话进行构建</p><p><code>H H/2 * * *</code> :  每两小时检查一次代码是否有更新，有的话进行构建</p><p><code>H 2 * * *</code> :  每天凌晨两点定时检查一次代码是否有更新，有的话进行构建</p><p><code>H H 15 * *</code> :  每月15号定时检查一次代码是否有更新，有的话进行构建</p><p><code>H 9 * * 1-5</code> :  周一至周五上午9点定时检查一次代码是否有更新，有的话进行构建</p><p>还有很多具体的配置，想了解的话配置的后面有个小问号，去哪里可以了解：）</p></li><li><p>构建环境</p><blockquote><p>Delete workspace before build starts  在生成开始之前删除工作区</p><p>Use secret text(s) or file(s) 使用机密文本或文件</p><p>Provide Configuration files  提供配置文件</p><p>Send files or execute commands over SSH before the build starts 在构建开始之前通过SSH发送文件或执行命令</p><p>Send files or execute commands over SSH after the build runs  在构建运行后通过SSH发送文件或执行命令</p><p>Abort the build if it’s stuck  如果生成被卡住，请中止它</p><p>Add timestamps to the Console Output  向控制台输出添加时间戳</p><p>Inspect build log for published Gradle build scans  检查生成日志中已发布的分级生成扫描</p><p>Provide Node &amp; npm bin/ folder to PATH  提供节点和npm bin/文件夹到路径 (此次选择node)</p></blockquote><p>但是初始是没有node &amp; npm这个选项的 需要做几步操作</p><p>1、运行服务器需要安装node环境</p><p>2、安装node插件<code>NodeJS Plugin</code> （安装方法上面说到过）</p><p>3、jenkins控制台选择 Manage jenkins  —&gt; Global Tool Configuration—&gt;最底下Node.js选择</p><p>4、 选择node.js安装  起别名、选择版本  记得勾选<code>Install automatically</code> 应用后保存退出</p><p>5、再去选择就会有对应的版本以供选择了</p></li><li><p>构建</p></li></ul><p>选择构建的方式（选项很多），这里选择Execute shell </p><p>然后就可以填写自定义的shell命令了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">ls</span><br><span class="line">node -v </span><br><span class="line">npm -v </span><br><span class="line">npm install </span><br><span class="line">npm run build</span><br><span class="line">echo &quot;打包构建成功！&quot;</span><br></pre></td></tr></table></figure><ul><li>构建后操作 </li></ul><blockquote><p>上一步我们已经成功执行到将我们的项目自动克隆下来进行了打包，生成了打包好的文件build,接下来就要执行发布，将打包好的文件放到我们的服务器，使其可以通过域名或者公网IP进行访问</p></blockquote><p>选择增加构建后操作步骤（选项依旧很多） 这里选择 Send build artifacts SSH 通过SSH发送我们构建的结果</p><p>此选项也需要安装插件 步骤：</p><p>1、 安装插件<code>Publish Over SSH</code></p><p>2、jenkins控制台选择 Manage jenkins  —&gt;Configure System系统配置—&gt;找到Publish over SSH 选项</p><p>3、选择SSH servers 并点击新增Server</p><p>4、填写name、发布服务器主机IP地址、用户名、发布目录</p><p>5、选择高级配置 进行连接密码和端口号的配置</p><p>6、配置完成后点击<code>Test configuration</code>进行测试连接   显示success 表示连接成功</p><p>7、点击应用并保存退出</p><p>然后回到我们刚才的配置，选择Send build artifacts SSH</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201205172521.png"></p><p>Source files :都上传那些文件 build/**  表示build文件夹下的所有文件</p><p>Remove prefix:去掉前缀 这里选择build/  表示只需要build文件夹里的文件</p><p>Remote directory :放置到远程服务器的那个文件夹下 </p><p>Exec command:执行的命令</p><p>至此就配置完成 ，就可以点击build now进行构建了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是jenkins&quot;&gt;&lt;a href=&quot;#一、什么是jenkins&quot; class=&quot;headerlink&quot; title=&quot;一、什么是jenkins&quot;&gt;&lt;/a&gt;一、什么是jenkins&lt;/h1&gt;&lt;p&gt;​    Jenkins是一个开源软件项目，是&lt;code&gt;基</summary>
      
    
    
    
    <category term="jenkins" scheme="http://gtliangming.github.io/categories/jenkins/"/>
    
    
    <category term="jenkins 项目部署" scheme="http://gtliangming.github.io/tags/jenkins-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Node.js实现github第三方登录</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jxf0007fanm67802zpz/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jxf0007fanm67802zpz/</id>
    <published>2020-12-09T05:50:52.000Z</published>
    <updated>2020-12-09T05:57:09.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是第三方登录"><a href="#一、什么是第三方登录" class="headerlink" title="一、什么是第三方登录"></a>一、什么是第三方登录</h3><h5 id="第三方登录是基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者权注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如Facebook，Twitter等，国内的比如微博、微信、QQ等。"><a href="#第三方登录是基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者权注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如Facebook，Twitter等，国内的比如微博、微信、QQ等。" class="headerlink" title="第三方登录是基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者权注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如Facebook，Twitter等，国内的比如微博、微信、QQ等。"></a>第三方登录是基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者权注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如Facebook，Twitter等，国内的比如微博、微信、QQ等。</h5><h5 id="第三方登录的目的是使用用户在其他平台上频繁使用的账号，来快速登录己方产品，也可以实现不注册就能登录，好处就是登录比较快捷，不用注册。"><a href="#第三方登录的目的是使用用户在其他平台上频繁使用的账号，来快速登录己方产品，也可以实现不注册就能登录，好处就是登录比较快捷，不用注册。" class="headerlink" title="第三方登录的目的是使用用户在其他平台上频繁使用的账号，来快速登录己方产品，也可以实现不注册就能登录，好处就是登录比较快捷，不用注册。"></a>第三方登录的目的是使用用户在其他平台上频繁使用的账号，来快速登录己方产品，也可以实现不注册就能登录，好处就是登录比较快捷，不用注册。</h5><h3 id="二、第三方账号登录流程"><a href="#二、第三方账号登录流程" class="headerlink" title="二、第三方账号登录流程"></a>二、第三方账号登录流程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110142954.png"></p><h4 id="获取授权-—-gt-绑定账号-—-gt-登陆成功-—-gt-解绑-换绑"><a href="#获取授权-—-gt-绑定账号-—-gt-登陆成功-—-gt-解绑-换绑" class="headerlink" title="获取授权 —-&gt; 绑定账号 —-&gt; 登陆成功 —-&gt; 解绑/换绑"></a>获取授权 —-&gt; 绑定账号 —-&gt; 登陆成功 —-&gt; 解绑/换绑</h4><h3 id="三、获取第三方账号登录授权"><a href="#三、获取第三方账号登录授权" class="headerlink" title="三、获取第三方账号登录授权"></a>三、获取第三方账号登录授权</h3><p>以Github 为例</p><p>流程：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20170828161704516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1bWluZzM4MzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="1、-在github创建应用"><a href="#1、-在github创建应用" class="headerlink" title="1、 在github创建应用"></a>1、 在github创建应用</h4><p><strong><em>Settings —-&gt;  Developer setting —-&gt; OAuth Apps —-&gt; New OAuth Apps</em></strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110143108.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110143216.png"></p><p>至此  应用就创建成功，接下来就可以使用！</p><p><strong><em>其他微博、腾讯QQ 、微信等都大同小异，只是申请流程会有不同，但是大体流程不会有出入，目的都是为了得到 <code>Client ID</code>和<code>Clinet Secret</code>(或者是APPID 和 APP Secret)</em></strong></p><h4 id="2、Nodejs实现后台登录处理"><a href="#2、Nodejs实现后台登录处理" class="headerlink" title="2、Nodejs实现后台登录处理"></a>2、Nodejs实现后台登录处理</h4><ul><li><h5 id="前端页面导航到我们的接口-（a标签）"><a href="#前端页面导航到我们的接口-（a标签）" class="headerlink" title="前端页面导航到我们的接口  （a标签）"></a>前端页面导航到我们的接口  （a标签）</h5></li></ul><p><code>https://github.com/login/oauth/authorize?client_id=</code>+刚创建的client_id+<code>&amp;redirect_url=</code>+回调方法接口的地址</p><p>Eg: <code>https://github.com/login/oauth/authorize?client_id=e2a1eaa9cf8f58c79077&amp;redirect_url=http://www.netbugs.cn:3002/api/authorizeLogin</code></p><ul><li><h5 id="得到授权的redirect-url-此回调地址会携带一个code"><a href="#得到授权的redirect-url-此回调地址会携带一个code" class="headerlink" title="得到授权的redirect_url 此回调地址会携带一个code"></a>得到授权的<code>redirect_url</code> 此回调地址会携带一个<code>code</code></h5></li></ul><p>  Eg：<code> http://www.netbugs.cn:3002/api/authorizeLogin?code=xxxxx</code></p><ul><li><h5 id="authorizeLogin-解析code并请求-github的access-token"><a href="#authorizeLogin-解析code并请求-github的access-token" class="headerlink" title="authorizeLogin  解析code并请求 github的access_token"></a><code>authorizeLogin</code>  解析code并请求 github的<code>access_token</code></h5></li></ul><p>  请求地址：<code>https://github.com/login/oauth/access_token</code></p><p>  请求body : <code>&#123; client_id,    client_secret, code&#125;</code></p><ul><li><h5 id="根据得到的access-token-获取用户信息"><a href="#根据得到的access-token-获取用户信息" class="headerlink" title="根据得到的access_token 获取用户信息"></a>根据得到的<code>access_token</code> 获取用户信息</h5></li></ul><p>  请求地址 ： <code>https://api.github.com/user?access_token=</code>+刚刚获取到的access_token</p><h4 id="3、得到用户信息"><a href="#3、得到用户信息" class="headerlink" title="3、得到用户信息"></a>3、得到用户信息</h4><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110142712.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110140652.png"></p><h5 id="测试链接-：-http-www-netbugs-cn-3002-api-loginGithub"><a href="#测试链接-：-http-www-netbugs-cn-3002-api-loginGithub" class="headerlink" title="测试链接 ： http://www.netbugs.cn:3002/api/loginGithub"></a>测试链接 ： <a href="http://www.netbugs.cn:3002/api/loginGithub">http://www.netbugs.cn:3002/api/loginGithub</a></h5><h5 id="注意事项：-各个不同的第三方登录基本上流程与此方法没有太大出入，只是在不同的平台，和自己此github应用的业务会有点不一样-只要阅读官方文档，都可以很好解决-：）"><a href="#注意事项：-各个不同的第三方登录基本上流程与此方法没有太大出入，只是在不同的平台，和自己此github应用的业务会有点不一样-只要阅读官方文档，都可以很好解决-：）" class="headerlink" title="注意事项： 各个不同的第三方登录基本上流程与此方法没有太大出入，只是在不同的平台，和自己此github应用的业务会有点不一样,只要阅读官方文档，都可以很好解决 ：）~"></a>注意事项： 各个不同的第三方登录基本上流程与此方法没有太大出入，只是在不同的平台，和自己此github应用的业务会有点不一样,只要阅读官方文档，都可以很好解决 ：）~</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、什么是第三方登录&quot;&gt;&lt;a href=&quot;#一、什么是第三方登录&quot; class=&quot;headerlink&quot; title=&quot;一、什么是第三方登录&quot;&gt;&lt;/a&gt;一、什么是第三方登录&lt;/h3&gt;&lt;h5 id=&quot;第三方登录是基于用户在第三方平台上已有的账号和密码来快速完成己方应</summary>
      
    
    
    
    <category term="node.js" scheme="http://gtliangming.github.io/categories/node-js/"/>
    
    
    <category term="node.js github" scheme="http://gtliangming.github.io/tags/node-js-github/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Npm发布自己的包</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jxq000ofanm3brs0ety/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jxq000ofanm3brs0ety/</id>
    <published>2020-12-09T05:50:04.000Z</published>
    <updated>2020-12-09T05:55:42.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、在npm发布可安装的代码"><a href="#一、在npm发布可安装的代码" class="headerlink" title="一、在npm发布可安装的代码"></a>一、在npm发布可安装的代码</h2><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>​    我们前端程序员，必不可少的经常使用<code>npm install xxx</code> 来安装各种各样的包。最近，我就很疑惑也很好奇，就为什么一条命令就可以将代码下载下来。那我自己的代码也能这么便捷的被下载吗？当然，结果是肯定的，本着好奇心害(cu)死(shi)头(jin)发(bu)，学习与了解后，接下来就来实现 : )</p><h4 id="1、关于npm"><a href="#1、关于npm" class="headerlink" title="1、关于npm"></a>1、关于npm</h4><p><strong>简单介绍一下npm：</strong><code>npm</code>大家应该都了解，它是node.js官方的包管理工具。我们只需要在控制台输入一些简单的命令就能使用它来更新，下载，上传node包（<a href="https://www.npmjs.com/">https://www.npmjs.com</a> ）。 </p><h4 id="2、发布准备"><a href="#2、发布准备" class="headerlink" title="2、发布准备"></a>2、发布准备</h4><ul><li><p>验证安装node和npm 已安装跳过 ^__^</p><p>基本的安装node在这里就不做过多赘述，只来验证一下是否安装了node,因为这是我们实现npm上发布代码的基础</p><p>打开命令行，输入<code>npm -v</code> 如果出现版本号，则说明已经安装</p></li><li><p>新建package.json</p><p>使用<code>npm init</code> 创建一个package.json文件（在项目根目录下新建一个<code>package.json</code>，这是一个用来描述你的包的json文件）</p><p>配置package.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;lmtestpack&quot;</span>,   <span class="comment">// name是你发布出去的npm包名</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.1&quot;</span>,  <span class="comment">// 发布版本</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;My NPM test pack&quot;</span>,                <span class="comment">// 对此npm包的描述</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,  <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;                                      <span class="comment">// 脚本命令</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node index.js&quot;</span>,                      </span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;nodemon&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;                              <span class="comment">// 仅在开发环境的包</span></span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^5.16.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nodemon&quot;</span>: <span class="string">&quot;^1.18.11&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;                                 <span class="comment">// 生产环境依赖包     </span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;16.13.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cli-color&quot;</span>: <span class="string">&quot;^2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;console-png&quot;</span>: <span class="string">&quot;^1.2.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;                                   <span class="comment">// 包所在仓库信息                                   </span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/GTliangming/demo-object.git&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Peter Leung&quot;</span>,                          <span class="comment">// 作者</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,                                 <span class="comment">// 描述代码的许可证 MIT、ISC或UNLICENSED</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [                                     <span class="comment">// 此包的搜索关键词</span></span><br><span class="line">    <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;express&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react.js&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写代码</p><p>虽然npm是允许发布一个空包（只含有<code>package.json</code>的包），但是这样的一个包是没有意义的。 我们如果没有代码，可以先加一个<code>README.md</code>来说明一下自己的包。或者直接代码(js,html,css等)放进来。</p></li></ul><h4 id="3、开始发布"><a href="#3、开始发布" class="headerlink" title="3、开始发布"></a>3、开始发布</h4><ul><li><p>创建npm账号</p><p>如果你没有创建过npm账号，可输入如下命令添加一个npm账号，并跟着提示填写要注册的账号和密码</p><p><code>npm adduser</code></p><p>依次输入用户名、密码和邮箱 （也可以进入 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 这个网址注册）</p></li><li><p>开始发布</p><p>输入命令<code>npm publish</code> 或<code>npm publish --access public</code> 进行发布</p></li><li><p>发布成功</p><p>这样你就可以在<a href="https://www.npmjs.com/">www.npmjs.com</a>搜索并找到你刚才发布的npm包名（如果需要登录，请使用刚才你在控制台注册的账号）</p><p>这样就可以通过<code>npm install xxx</code>来安装你的包了(例如：npm install lmtestpack)</p></li></ul><h4 id="4、常见问题"><a href="#4、常见问题" class="headerlink" title="4、常见问题"></a>4、常见问题</h4><ul><li><p>1.如果需要更新包，在修改完代码后请记得修改<code>package.json</code>包的<code>version</code>字段，然后 <code>npm publish</code>。否则会无法发布；</p></li><li><p>2.如果在发布中显示类似’请确认你是否有权限更新xxx包’的英文提示，这就说明你的包名有人使用了。换个名字就好啦。</p></li><li><p>3.如果你想删除一个自己发布过的包，请使用命令 <code>npm unpublish --force xxx</code> （xxx为包名），一些没有意义的包还是建议删掉。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、在npm发布可安装的代码&quot;&gt;&lt;a href=&quot;#一、在npm发布可安装的代码&quot; class=&quot;headerlink&quot; title=&quot;一、在npm发布可安装的代码&quot;&gt;&lt;/a&gt;一、在npm发布可安装的代码&lt;/h2&gt;&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;</summary>
      
    
    
    
    <category term="npm" scheme="http://gtliangming.github.io/categories/npm/"/>
    
    
    <category term="npm git" scheme="http://gtliangming.github.io/tags/npm-git/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器WebScrape插件d的使用</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jxz000ufanm3lq29c5q/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jxz000ufanm3lq29c5q/</id>
    <published>2020-12-09T05:49:04.000Z</published>
    <updated>2020-12-09T05:55:17.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web-Scraper"><a href="#Web-Scraper" class="headerlink" title="Web Scraper"></a>Web Scraper</h1><p>官方文档 <a href="https://www.webscraper.io/documentation?utm_source=extension&amp;utm_medium=popup">https://www.webscraper.io/documentation?utm_source=extension&amp;utm_medium=popup</a></p><h2 id="一、什么是Web-Scraper"><a href="#一、什么是Web-Scraper" class="headerlink" title="一、什么是Web Scraper"></a>一、什么是Web Scraper</h2><p>web scraper是一款网站数据提取工具，类似于爬虫，但不需要像python爬虫那样编写代码，使用门槛较低，适用于轻度的数据爬取。web scraper主要以谷歌扩展插件的形式存在。</p><h2 id="二、如何安装Web-Scraper"><a href="#二、如何安装Web-Scraper" class="headerlink" title="二、如何安装Web Scraper"></a>二、如何安装Web Scraper</h2><p>打开谷歌应用商店，搜索栏搜索web scraper,点击添加</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135614.png"></p><h2 id="三、使用介绍"><a href="#三、使用介绍" class="headerlink" title="三、使用介绍"></a>三、使用介绍</h2><h5 id="1、确定谷歌浏览器安装了Web-Scraper后，打开开发者工具界面，并使其悬浮在浏览器底部，可在工具栏发现web-scraper一项"><a href="#1、确定谷歌浏览器安装了Web-Scraper后，打开开发者工具界面，并使其悬浮在浏览器底部，可在工具栏发现web-scraper一项" class="headerlink" title="1、确定谷歌浏览器安装了Web Scraper后，打开开发者工具界面，并使其悬浮在浏览器底部，可在工具栏发现web scraper一项"></a>1、确定谷歌浏览器安装了Web Scraper后，打开开发者工具界面，并使其悬浮在浏览器底部，可在工具栏发现web scraper一项</h5><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135607.png"></p><h5 id="2、功能栏介绍"><a href="#2、功能栏介绍" class="headerlink" title="2、功能栏介绍"></a>2、功能栏介绍</h5><ul><li>create new sitemap  创建新的网站查询</li></ul><p><strong>Create Sitemap</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135603.png"></p><blockquote><p>sitemap name :名称 随便起 (非中文)</p><p>Start URL ：需要抓取数据的网站链接</p><p>以百度为例创建查询</p></blockquote><p><strong>Import Sitemap</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135556.png"></p><blockquote><p>Sitemap Json : 导入json数据进行抓取</p><p>Rename Sitemap : 起名字</p></blockquote><ul><li><p>Sitemap baidu</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135550.png"></p></li></ul><blockquote><p>Selectors :查看创建的筛选器</p><p>Selectors graph :筛选的层级结构</p><p>Edit metadata : 编辑之前创建的网站</p><p>Scrape: 开始根据创建的筛选器开始抓取</p><p>Browser : 在线查看筛选的数据 （需在抓取完成后查看）</p><p>Export Sitemap : 导出创建的查询网站信息</p><p>Export data as CSV ：导出抓取的数据以CSV文件格式</p></blockquote><h2 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135542.png"></p><p>抓取顶部导航的名称及链接</p><h3 id="1、第一步-创建sitemap"><a href="#1、第一步-创建sitemap" class="headerlink" title="1、第一步 创建sitemap"></a>1、第一步 创建sitemap</h3><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135536.png"></p><h3 id="2、创建筛选器"><a href="#2、创建筛选器" class="headerlink" title="2、创建筛选器"></a>2、创建筛选器</h3><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135530.png"></p><p>单击创建的sietmap 然后点左下角 Add new Selector（可添加多个）</p><p>​    <strong>筛选标题筛选器</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135525.png"></p><blockquote><p>id：名字随便起</p><p>Type: 类型 可选  （具有较多类型，建议查看官网）</p><p>Selector ： 先点击selector ，然后点击网站上要抓取的东西，等被红框框住，就可选择下一项（会自动帮你多选），选择完成后点击Done selecting</p><p>Element Preview :预览选择的元素</p><p>Data Preview :预览选择数据</p><p>Multiple:是否选择多个元素</p><p>Regex :正则筛选规则</p><p>Parent Selectors :选择父级筛选规则</p></blockquote><p>​    <strong>筛选链接筛选器</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135519.png"></p><p>​    <strong>选择器创建完成</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135515.png"></p><p>可点击Sitemaps baidu —-&gt;Selectors graph 查看创建的筛选器层级</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135503.png"></p><h3 id="3-、开始筛选"><a href="#3-、开始筛选" class="headerlink" title="3 、开始筛选"></a>3 、开始筛选</h3><p>点击Sitemaps baidu —&gt; Scrape</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135456.png"></p><blockquote><p>请求时间与页面滚动延迟，可自定义 完成后点击 Start Scraping 会跳出一个新的页面，待整个页面自动关闭后（关闭时间与筛选的复杂程度与数据量大小有关），表示已经筛选完成</p></blockquote><h3 id="4、查看结果"><a href="#4、查看结果" class="headerlink" title="4、查看结果"></a>4、查看结果</h3><p>点击Sitemaps baidu —- &gt;Browser</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135442.png"></p><p>点击refresh  就可查看到抓取的数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://lm-imgstore.oss-cn-shanghai.aliyuncs.com/img/20201110135354.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web-Scraper&quot;&gt;&lt;a href=&quot;#Web-Scraper&quot; class=&quot;headerlink&quot; title=&quot;Web Scraper&quot;&gt;&lt;/a&gt;Web Scraper&lt;/h1&gt;&lt;p&gt;官方文档 &lt;a href=&quot;https://www.webscrap</summary>
      
    
    
    
    <category term="chrome" scheme="http://gtliangming.github.io/categories/chrome/"/>
    
    
    <category term="chrome" scheme="http://gtliangming.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Node.js上传文件至阿里云oss并返回访问url</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jxe0006fanm0egaeds2/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jxe0006fanm0egaeds2/</id>
    <published>2020-12-09T05:47:44.000Z</published>
    <updated>2020-12-09T05:56:54.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-js上传文件至阿里云oss并返回访问url"><a href="#Node-js上传文件至阿里云oss并返回访问url" class="headerlink" title="Node.js上传文件至阿里云oss并返回访问url"></a>Node.js上传文件至阿里云oss并返回访问url</h2><h3 id="一、什么是阿里云oss"><a href="#一、什么是阿里云oss" class="headerlink" title="一、什么是阿里云oss"></a>一、什么是阿里云oss</h3><p><a href="https://www.aliyun.com/">阿里云官网 ：https://www.aliyun.com</a></p><p>阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。它具有与平台无关的RESTful API接口，能够提供99.999999999%（11个9）的数据可靠性和99.99%的服务可用性。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p><p>您可以使用阿里云提供的API/SDK接口或者OSS迁移工具轻松地将海量数据移入或移出阿里云OSS。数据存储到阿里云OSS以后，您可以选择标准类型（Standard）的阿里云OSS服务作为移动应用、大型网站、图片分享或热点音视频的主要存储方式，也可以选择成本更低、存储期限更长的低频访问类型（Infrequent Access）和归档类型（Archive）的阿里云OSS服务作为不经常访问数据的备份和归档。</p><p><a href="https://help.aliyun.com/document_detail/31947.html">阿里云OSS官方介绍地址：https://help.aliyun.com/document_detail/31947.html</a></p><p>具体的怎么开通阿里云oss、新建Bucket，创建accessKeyId和accessKeySecret等，百度有很多</p><p>这里提供一个参考链接 ：<a href="https://blog.csdn.net/qq_15980721/article/details/102490019">https://blog.csdn.net/qq_15980721/article/details/102490019</a></p><h3 id="二、前端表单提交-后端node请求"><a href="#二、前端表单提交-后端node请求" class="headerlink" title="二、前端表单提交+后端node请求"></a>二、前端表单提交+后端node请求</h3><p>需要安装node的阿里云oss插件<code>ali-oss</code>  与上传所需的<code>multer</code>、<code>co</code></p><p><code>npm install ali-oss --save</code></p><p><code> npm install --save multer</code></p><p><code>npm install co</code></p><blockquote><p>Multer 是一个 node.js 中间件，用于处理 <code>multipart/form-data</code> 类型的表单数据，它主要用于上传文件。它是写在 <a href="https://github.com/mscdex/busboy">busboy</a> 之上非常高效。</p><p><strong>注意</strong>: Multer 不会处理任何非 <code>multipart/form-data</code> 类型的表单数据。</p><p><a href="https://www.npmjs.com/package/multer">传送门</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">var</span> OSS = <span class="built_in">require</span>(<span class="string">&#x27;ali-oss&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer=<span class="built_in">require</span>(<span class="string">&quot;multer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&quot;co&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置阿里云连接参数</span></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> OSS(&#123;</span><br><span class="line">  <span class="comment">// 你的oss的源地址、可以在阿里云的oss对象存储内的bucket概览内看到</span></span><br><span class="line">  region:<span class="string">&#x27;oss-cn-beijing&#x27;</span>, </span><br><span class="line"><span class="comment">// 这里填入刚生成的id和key</span></span><br><span class="line">  accessKeyId:<span class="string">&#x27;****************&#x27;</span>,</span><br><span class="line">  accessKeySecret:<span class="string">&#x27;*************8&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义访问的bucket</span></span><br><span class="line"><span class="keyword">var</span> ali_oss_bucket =<span class="string">&#x27;bucket-lm-demo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置multer</span></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123; </span><br><span class="line">  dest: <span class="string">&quot;public/image/&quot;</span>, <span class="comment">//此路径为本地存储的路径，以后会删除</span></span><br><span class="line">&#125;).single(<span class="string">&quot;avatar&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/getImg&#x27;</span>,upload, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111111</span>,req.file)</span><br><span class="line">    <span class="comment">// 将文件名改为了 例如 2020-09-15-文件名前六位+文件后缀</span></span><br><span class="line">    <span class="keyword">var</span> fileName = setFileName(req.file.originalname)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>,fileName)</span><br><span class="line"><span class="comment">// 文件重命名 </span></span><br><span class="line">    fs.rename(<span class="string">&#x27;public/image/&#x27;</span>+req.file.filename,<span class="string">&#x27;public/image/&#x27;</span>+fileName,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          res.json(&#123;</span><br><span class="line">            code:<span class="number">400</span>,</span><br><span class="line">            msg:<span class="string">&quot;文件上传失败&quot;</span>,</span><br><span class="line">            error:<span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 此部分为上传至阿里云</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 本地图片的路径</span></span><br><span class="line">          <span class="keyword">var</span> localFile = <span class="string">&#x27;public/image/&#x27;</span>+fileName;</span><br><span class="line">          <span class="comment">// 上传后保存的路径</span></span><br><span class="line">          <span class="keyword">var</span> key = <span class="string">&#x27;image/&#x27;</span>+fileName;</span><br><span class="line">          </span><br><span class="line">          co(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            client.useBucket(ali_oss.bucket);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> client.put(key,localFile);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">33333</span>,result)</span><br><span class="line">            <span class="comment">// 上传完成后删除本地文件</span></span><br><span class="line">            fs.unlinkSync(localFile);</span><br><span class="line">            res.json(&#123;</span><br><span class="line">              code:<span class="number">200</span>,</span><br><span class="line">              msg:<span class="string">&quot;success&quot;</span>,</span><br><span class="line">              <span class="comment">// 将网址返回</span></span><br><span class="line">              resultUrl:result.res.requestUrls</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">          &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            fs.unlinkSync(localFile);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">444</span>,err)</span><br><span class="line">            res.json(&#123;</span><br><span class="line">              code:<span class="number">401</span>,</span><br><span class="line">              msg:<span class="string">&quot;文件上传失败&quot;</span>,</span><br><span class="line">              error:<span class="built_in">JSON</span>.stringify(err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">  res.render(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFileName</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = val.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> actureName =val.slice(<span class="number">0</span>,index)</span><br><span class="line">  <span class="keyword">const</span> actureType =val.slice(index,val.length)</span><br><span class="line">  <span class="keyword">const</span> Time = setTime();</span><br><span class="line">  <span class="keyword">if</span>(actureName.length&gt;=<span class="number">6</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Time + actureName.slice(<span class="number">0</span>,<span class="number">6</span>)+actureType;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Time+actureName+actureType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dateStr = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> year = dateStr.getFullYear().toString().padStart(<span class="number">4</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> month = (dateStr.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> day = dateStr.getDate().toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span>-`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>前端请求页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;Box&quot;</span>&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;http://127.0.0.1:3001/uploads/getImg&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;avatar&quot;</span> accept=<span class="string">&quot;image/*&quot;</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span>&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;h2&gt;以下为预览效果：&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="三、-前端antd的upload上传组件实现上传"><a href="#三、-前端antd的upload上传组件实现上传" class="headerlink" title="三、 前端antd的upload上传组件实现上传"></a>三、 前端antd的upload上传组件实现上传</h3><p>​    antd是在react内很好用的一个组件库，不仅好看还好用，这部分就来使用它来上传至阿里云OSS</p><p><strong>前端</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// antd的所用的组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Upload, message, Input, Button &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入阿里云插件</span></span><br><span class="line"><span class="keyword">import</span> oss <span class="keyword">from</span> <span class="string">&#x27;ali-oss&#x27;</span>;</span><br><span class="line"><span class="comment">// import moment from &#x27;moment&#x27;;</span></span><br><span class="line"><span class="keyword">import</span> &#123; setFileName &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./tooss.css&#x27;</span>;</span><br><span class="line"><span class="comment">// 点击复制到粘贴板的一个react插件</span></span><br><span class="line"><span class="keyword">import</span> CopyToClipboard <span class="keyword">from</span> <span class="string">&#x27;react-copy-to-clipboard&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase64</span>(<span class="params">img:any, callback:any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> callback(reader.result));</span><br><span class="line">  reader.readAsDataURL(img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="function">(<span class="params">self:any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;token&#125; = self</span><br><span class="line">  <span class="comment">// 当时使用的插件版本为5.2</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  return new oss.Wrapper(&#123;</span></span><br><span class="line"><span class="comment">    accessKeyId: token.access_key_id,</span></span><br><span class="line"><span class="comment">    accessKeySecret: token.access_key_secret,</span></span><br><span class="line"><span class="comment">    region: &#x27;&#x27;, //</span></span><br><span class="line"><span class="comment">    bucket: &#x27;&#x27;,//</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 2018-12-29更新</span></span><br><span class="line">  <span class="comment">// ali-oss v6.x版本的写法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> oss(&#123;</span><br><span class="line">    accessKeyId: token.access_key_id,</span><br><span class="line">    accessKeySecret: token.access_key_secret,</span><br><span class="line">    region: token.OSS_ENDPOINT, <span class="comment">//</span></span><br><span class="line">    bucket: token.OSS_BUCKET,<span class="comment">//</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件的路径，使用日期命名文件目录 文件的名字可以自定义这个部分随意</span></span><br><span class="line"><span class="keyword">const</span> uploadPath = <span class="function">(<span class="params">path:any, file:any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = setFileName(file.name)</span><br><span class="line">  <span class="comment">// return `$&#123;moment().format(&#x27;YYYYMMDD&#x27;)&#125;/$&#123;file.name.split(&quot;.&quot;)[0]&#125;.$&#123;file.type.split(&quot;/&quot;)[1]&#125;`</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="string">`image/<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传方法</span></span><br><span class="line"><span class="keyword">const</span> UploadToOss = <span class="function">(<span class="params">self:any, path:any, file:any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = uploadPath(path, file)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    client(self).multipartUpload(url, file,&#123;&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ExampleStatus &#123;</span><br><span class="line">  loading:boolean;</span><br><span class="line">  fileList: any[];</span><br><span class="line">  token:any;</span><br><span class="line">  UrlList:any;</span><br><span class="line">  copied:boolean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadToOSS</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;</span>&#123;&#125;,ExampleStatus&gt;&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props:any)&#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      token: &#123;</span><br><span class="line">        access_key_id: <span class="string">&#x27;***************&#x27;</span>, <span class="comment">// oss的key_id</span></span><br><span class="line">        access_key_secret: <span class="string">&#x27;****************&#x27;</span>, <span class="comment">// oss的secret</span></span><br><span class="line">        OSS_ENDPOINT: <span class="string">&#x27;oss-cn-beijing&#x27;</span>,  <span class="comment">// 自己oss服务器的源地址// </span></span><br><span class="line">        OSS_BUCKET: <span class="string">&#x27;*********&#x27;</span>, <span class="comment">// 自己要上传的oss服务器的bucket的名字</span></span><br><span class="line">      &#125;,</span><br><span class="line">      UrlList:[],<span class="comment">// 获取阿里云oss内所有图片的链接的一个数组</span></span><br><span class="line">      fileList:[</span><br><span class="line">        &#123;</span><br><span class="line">          uid: <span class="string">&#x27;-1&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;image.png&#x27;</span>,</span><br><span class="line">          status: <span class="string">&#x27;done&#x27;</span>,</span><br><span class="line">          url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      copied:<span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> componentDidMount()&#123;</span><br><span class="line">   <span class="keyword">await</span> <span class="built_in">this</span>.getUploadInfo();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11111</span>,<span class="built_in">this</span>.state.UrlList)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这个方法是一个我自己node写的一个获取阿里云oss内指定文件夹下的所有的文件，目的就是能让我一次性获取我存的所有图片的链接，实现一个展示的作用</span></span><br><span class="line">  getUploadInfo= <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// const HOST = &quot;http://localhost:3003/uploads2/getImg&quot;;</span></span><br><span class="line">    <span class="keyword">const</span> HOST = <span class="string">&quot;http://xxx.xxx.xxx.xxx:3003/toOSS/getImg&quot;</span></span><br><span class="line">   <span class="keyword">await</span> axios.get(HOST).then(<span class="function">(<span class="params">result:any</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.data.code===<span class="number">400</span>)&#123;</span><br><span class="line">          <span class="keyword">const</span> data = result.data.result.objects;</span><br><span class="line">          <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            UrlList:data</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">info:any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      fileList:info.fileList</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (info.file.status === <span class="string">&#x27;uploading&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">loading</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.file.status === <span class="string">&#x27;done&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// Get this url from response in real world.</span></span><br><span class="line">      getBase64(info.file.originFileObj, <span class="function">(<span class="params">imageUrl:any</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        loading: <span class="literal">false</span>,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeUpload = <span class="function">(<span class="params">file:any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isJPG = file.type === <span class="string">&#x27;image/jpeg&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isJPG) &#123;</span><br><span class="line">      message.error(<span class="string">&#x27;You can only upload JPG file!&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> isLt2M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isLt2M) &#123;</span><br><span class="line">      message.error(<span class="string">&#x27;Image must smaller than 2MB!&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">    reader.onloadend = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用ossupload覆盖默认的上传方法</span></span><br><span class="line">      UploadToOss(<span class="built_in">this</span>.state, <span class="string">&#x27;上传路径oss配置信息&#x27;</span>, file).then(<span class="function">(<span class="params">data:any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2222</span>,data.res)</span><br><span class="line">        <span class="keyword">if</span>(data.res.status===<span class="number">200</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.getUploadInfo()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          message.error(<span class="string">&quot;上传失败!&quot;</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不调用默认的上传方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;fileList,UrlList&#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;uploadBox&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;小梁图片上传 ^_^&lt;/h2&gt;</span><br><span class="line">        &lt;Upload</span><br><span class="line">          name=<span class="string">&quot;avatar&quot;</span></span><br><span class="line">          listType=<span class="string">&quot;picture-card&quot;</span></span><br><span class="line">          className=<span class="string">&quot;avatar-uploader&quot;</span></span><br><span class="line">          beforeUpload=&#123;<span class="built_in">this</span>.beforeUpload&#125;</span><br><span class="line">          onChange=&#123;<span class="built_in">this</span>.handleChange&#125;</span><br><span class="line">          fileList=&#123;fileList&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;fileList.length &lt; <span class="number">5</span> &amp;&amp; <span class="string">&#x27;+ 点击上传&#x27;</span>&#125;</span><br><span class="line">        &lt;/Upload&gt;</span><br><span class="line">        &lt;ul className=<span class="string">&quot;urlList&quot;</span>&gt;</span><br><span class="line">          &#123;UrlList.map(<span class="function">(<span class="params">item:any,index:number</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">return</span>(</span><br><span class="line">                &lt;li key=&#123;index&#125; className=<span class="string">&quot;liItem&quot;</span>&gt;</span><br><span class="line">                  &lt;span className=<span class="string">&quot;itemspan&quot;</span>&gt;&#123;item.name&#125;:&lt;/span&gt;</span><br><span class="line">                  &lt;Input type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                    id=&#123;<span class="string">`item<span class="subst">$&#123;index&#125;</span>`</span>&#125;</span><br><span class="line">                    value=&#123;item.url&#125; </span><br><span class="line">                    className=<span class="string">&quot;item&quot;</span> </span><br><span class="line">                    onChange=&#123;<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">copied</span>:<span class="literal">false</span>&#125;)&#125;/&gt;</span><br><span class="line">                  &lt;CopyToClipboard text=&#123;item.url&#125;  <span class="comment">// 这里实现一个点击将文本复制到粘贴板的作用</span></span><br><span class="line">                    onCopy=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                      message.success(<span class="string">&quot;复制成功!&quot;</span>,<span class="number">1</span>)</span><br><span class="line">                      <span class="built_in">this</span>.setState(&#123;<span class="attr">copied</span>:<span class="literal">true</span>&#125;</span><br><span class="line">                      )&#125;&#125;&gt;</span><br><span class="line">                    &lt;Button type=<span class="string">&quot;primary&quot;</span>&gt;点击复制&lt;/Button&gt;</span><br><span class="line">                  &lt;/CopyToClipboard&gt; </span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">              )</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UploadToOSS;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后端node （实现获取oss指定文件夹下的所有文件）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> OSS = <span class="built_in">require</span>(<span class="string">&#x27;ali-oss&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> OSS(&#123;</span><br><span class="line">  accessKeyId: <span class="string">&#x27;****************&#x27;</span>, </span><br><span class="line">  accessKeySecret: <span class="string">&#x27;***************&#x27;</span>,</span><br><span class="line">  region: <span class="string">&#x27;oss-cn-beijing&#x27;</span>, </span><br><span class="line">  bucket: <span class="string">&#x27;***********&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的参数有4个 我只做了数量的限制 具体查看 </span></span><br><span class="line"><span class="comment">// https://help.aliyun.com/document_detail/111389.html?spm=a2c4g.11186623.2.10.644e898eFaa3Cr#concept-jjz-wxh-dhb </span></span><br><span class="line">router.get(<span class="string">&#x27;/getImg&#x27;</span>,<span class="keyword">async</span> (req, res, next)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> client.list(&#123;</span><br><span class="line">    <span class="string">&quot;max-keys&quot;</span>:<span class="number">20</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">22222</span>,result)</span><br><span class="line">  <span class="keyword">if</span>(result.res.status===<span class="number">200</span>)&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">400</span>,</span><br><span class="line">      msg:<span class="string">&quot;20条获取成功！&quot;</span>,</span><br><span class="line">      result:result</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">401</span>,</span><br><span class="line">      msg:<span class="string">&quot;获取失败！&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.render(<span class="string">&quot;index2&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    </p><h3 id="四、问题解决"><a href="#四、问题解决" class="headerlink" title="四、问题解决"></a>四、问题解决</h3><h4 id="1、上传后访问图片链接直接下载而非访问图片"><a href="#1、上传后访问图片链接直接下载而非访问图片" class="headerlink" title="1、上传后访问图片链接直接下载而非访问图片"></a>1、上传后访问图片链接直接下载而非访问图片</h4><p>当我们把图片上传到阿里云oss后，会得到此图片的链接，但是呢，当我们在浏览器页面打开这个链接，竟然是直接下载了这个图片，What ？。是不是很难受！所以我们就要解决这个问题（在标签内使用是可以滴）</p><p>————————&gt;我找了很多 配置域名，请求头，都么有解决我的问题，然后我就发现了这个–<code>PicGo</code>真香</p><p><a href="https://www.jianshu.com/p/9d91355e8418">安装教程</a>，</p><h4 id="2、上传报错-You-have-no-right-to-access-this-object-because-of-bucket-acl"><a href="#2、上传报错-You-have-no-right-to-access-this-object-because-of-bucket-acl" class="headerlink" title="2、上传报错: You have no right to access this object because of bucket acl"></a>2、上传报错: You have no right to access this object because of bucket acl</h4><p><a href="https://blog.csdn.net/iteye_19045/article/details/106721450">https://blog.csdn.net/iteye_19045/article/details/106721450</a></p><h3 id="四、后续可以改进的地方"><a href="#四、后续可以改进的地方" class="headerlink" title="四、后续可以改进的地方"></a>四、后续可以改进的地方</h3><p>我们这样上传，可以实现文件上传，但是如果再加上上传的进度条，以及获取上传了的所有的图片以及文件呢？</p><p>文件上传进度条可参考：<a href="https://github.com/berwin/aliyun-oss-upload-stream">https://github.com/berwin/aliyun-oss-upload-stream</a></p><p>获取已经上传的参考：<strong>参考SDK <a href="https://help.aliyun.com/document_detail/32068.html?spm=a2c4g.11186623.6.1262.6fdf64edKkYqlU">阿里云ossNode.js</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Node-js上传文件至阿里云oss并返回访问url&quot;&gt;&lt;a href=&quot;#Node-js上传文件至阿里云oss并返回访问url&quot; class=&quot;headerlink&quot; title=&quot;Node.js上传文件至阿里云oss并返回访问url&quot;&gt;&lt;/a&gt;Node.js上</summary>
      
    
    
    
    <category term="node.js" scheme="http://gtliangming.github.io/categories/node-js/"/>
    
    
    <category term="node.js OSS" scheme="http://gtliangming.github.io/tags/node-js-OSS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+TravisCI自动部署项目至github</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jwl0000fanm8zubfx6t/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jwl0000fanm8zubfx6t/</id>
    <published>2020-12-09T05:46:51.000Z</published>
    <updated>2020-12-09T05:47:14.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是 Hexo 这里就不做过多的介绍了，百度一下有很多介绍的<br>这里来介绍一下什么是 Travis CI</p></blockquote><h3 id="一、什么是-Travis-CI"><a href="#一、什么是-Travis-CI" class="headerlink" title="一、什么是 Travis CI"></a>一、什么是 Travis CI</h3><p>作为一个专(diao)业(si)研(cheng)发(xu)人员，开发代码、与产品和 bug 斗志斗勇已经都让我们的发量不保了，很多的项目构建与发布还要让头发遭罪，这不能忍。为了提高开发的效率，自动构建和测试的自动化工具就宛如一个利器，其中的<code>Travis CI</code>  就是其中免费的、简单的、而且市场占比最高的一个。</p><p><strong>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</strong><br>**</p><blockquote><p>什么是持续集成服务 ？<br>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码”集成”到主干。<br>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p></blockquote><h3 id="二、创建项目的-github-仓库"><a href="#二、创建项目的-github-仓库" class="headerlink" title="二、创建项目的 github 仓库"></a>二、创建项目的 github 仓库</h3><h4 id="1、github"><a href="#1、github" class="headerlink" title="1、github"></a>1、github</h4><p>至于什么 github 是什么、github 怎么用、github 怎么创建仓库，这里就不做赘述<br>相关介绍可以点击了解一下：<br><a href="https://www.leiue.com/what-is-github">https://www.leiue.com/what-is-github</a><br><a href="https://www.leiue.com/what-is-github">https://www.leiue.com/what-is-github</a></p><h4 id="2、登录-github-创建一个用来放置-hexo-博客项目的仓库"><a href="#2、登录-github-创建一个用来放置-hexo-博客项目的仓库" class="headerlink" title="2、登录 github 创建一个用来放置 hexo 博客项目的仓库"></a>2、登录 github 创建一个用来放置 hexo 博客项目的仓库</h4><p>创建 hexo 博客可查看我另外一篇文章<a href="https://www.yuque.com/jijiangyongyoubakuaifujilm/kb/al1tyx">hexo 博客搭建与部署 github</a></p><h3 id="三、使用-Travis-CI-托管博客项目"><a href="#三、使用-Travis-CI-托管博客项目" class="headerlink" title="三、使用 Travis CI 托管博客项目"></a>三、使用 Travis CI 托管博客项目</h3><p>登录<code>Travis CI</code>官网，官网地址<a href="https://travis-ci.org/">https://travis-ci.org/</a> 选择 Github 登录<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598517318983-7261f671-9820-4ddb-8fd3-ab128bb7fa12.png#align=left&display=inline&height=529&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=1130&size=62588&status=done&style=none&width=1130" alt="image.png"><br>登录自己的 github 账号后 就可看到登陆成功的界面，点击头像右边的下拉标签，选择 Setting,即可看到下图的样子，主要分为三部分。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598517445333-6810df05-c003-444c-813f-1b724f566443.png#align=left&display=inline&height=762&margin=%5Bobject%20Object%5D&name=image.png&originHeight=762&originWidth=1097&size=120720&status=done&style=none&width=1097" alt="image.png"><br>1、 左边的部分是我们的 github 账户信息。可以点击<code>Sync account</code> 实时同步我们的账户信息<br>2、右上角是我们登陆 Travis CI 的账户，包括设置和退出登陆，设置以后会用到<br>3、重要部分！！！！<br>在这可以看到我们 github 账户下的所有的仓库。我们需要托管那个仓库，就在右边将它的开关打开，此时的 Travis CI 就会帮我们监管这个仓库的活动。当然，仓库也不是说管就能管的，我们要给他一定的权限</p><h3 id="四、赋予-Travis-CI-管理仓库的权限"><a href="#四、赋予-Travis-CI-管理仓库的权限" class="headerlink" title="四、赋予 Travis CI 管理仓库的权限"></a>四、赋予 Travis CI 管理仓库的权限</h3><p>赋予权限，我们就需要使用到 github 的<code>Personal access tokens</code> 接下来我们来说怎么生成这个 Token 并且使用，</p><h4 id="1、生成-Token"><a href="#1、生成-Token" class="headerlink" title="1、生成 Token"></a>1、生成 Token</h4><p>步骤：<br>登录 github—&gt; 点击右上角头像，选择 setting 并点击—&gt;<br>在左侧导航栏最底下选择<code>Developer setting</code>—&gt;然后选择<code>Personal access tokens</code><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598518197562-1f67e48c-0483-4b0d-9c39-f8cfffe62f34.png#align=left&display=inline&height=252&margin=%5Bobject%20Object%5D&name=image.png&originHeight=252&originWidth=1041&size=43472&status=done&style=none&width=1041" alt="image.png"><br>然后选择 Generate new token<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598518325096-c117920a-bdff-4075-95d0-30e4ecc2cf9c.png#align=left&display=inline&height=605&margin=%5Bobject%20Object%5D&name=image.png&originHeight=605&originWidth=1066&size=90394&status=done&style=none&width=1066" alt="image.png"><br>给 token 起个名字，底下选取一下权限，前三项建议都选上，如果不知道选择那个，项目自用也不考虑安全性的问题的话，可以全选。选择完权限后，点击 Generate token ，token 就生成了<br>！！！！划重点，划重点，划重点，重要的事情说三遍！<br>因为 token 只会在生成后显示一次，之后就不会显示，如果忘记，就只能删除后重新创建了。所以此时需要把这个 token 保存起来，安全的地方。因为后面会用到。</p><h4 id="2、将权限赋予给-Travis-Ci"><a href="#2、将权限赋予给-Travis-Ci" class="headerlink" title="2、将权限赋予给 Travis Ci"></a>2、将权限赋予给 Travis Ci</h4><p>所谓的权限赋予，就是把刚才生成的 token 赋予给 Travis CI 托管的仓库。<br>登录 Travis ci 点击需要托管的仓库后面的 setting 选项<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598518780158-b3f0e7f5-4115-487b-920d-b6cac119b354.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=698&size=5505&status=done&style=none&width=698" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598518846941-bab61896-e0de-40db-bf9f-1760c034e526.png#align=left&display=inline&height=676&margin=%5Bobject%20Object%5D&name=image.png&originHeight=676&originWidth=1121&size=79574&status=done&style=none&width=1121" alt="image.png"><br>首先打开最上面的 General 内的开关</p><blockquote><p>依据版本，有些会有 Build only if .travis.yml is present 开关，有的话一同打开</p></blockquote><p>这样，当向项目 push 代码的时候 travis CI 就会据  <code>.travis.yml</code>  的内容去部署我们的项目了。</p><h3 id="五、告诉-Travis-CI-怎么部署—创建-travis-yml"><a href="#五、告诉-Travis-CI-怎么部署—创建-travis-yml" class="headerlink" title="五、告诉 Travis CI 怎么部署—创建.travis.yml"></a>五、告诉 Travis CI 怎么部署—创建.travis.yml</h3><p>建议在开始配置之前，先去官网了解一下.travis.yml 内各个钩子方法的作用以及执行顺序<br>传送门：<a href="https://docs.travis-ci.com/">https://docs.travis-ci.com/</a></p><p><strong>以下两种方法，都要提前在博客项目的根目录下创建.travis.yml 文件</strong></p><h4 id="1、方案二：普通方法"><a href="#1、方案二：普通方法" class="headerlink" title="1、方案二：普通方法"></a>1、方案二：普通方法</h4><p>直接配置.yml 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line"># 配置语言与node版本</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line"></span><br><span class="line"># 缓存</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">    - node_modules</span><br><span class="line">before_install:</span><br><span class="line">  - npm install -g hexo-cli</span><br><span class="line">  - npm install -g hexo</span><br><span class="line">  - npm install hexo-deployer-git@2.1.0 --save</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - npm i</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">  - hexo clean</span><br><span class="line"></span><br><span class="line">  # generate static files</span><br><span class="line">  - hexo generate</span><br><span class="line">after_success:</span><br><span class="line"># 这里的命令都可以自行添加（例如我加了ls，想要查看编译后文件都有那些）</span><br><span class="line">  - cd .&#x2F;public</span><br><span class="line">  - ls</span><br><span class="line">  - git init</span><br><span class="line">  - git config --global user.name &quot;yourname&quot;</span><br><span class="line">  - git config --global user.email &quot;youremail&quot;</span><br><span class="line">  - git add  .</span><br><span class="line">  - git commit -m &quot;Travis CI Auto Builder&quot;</span><br><span class="line">  - git push --quiet --force https:&#x2F;&#x2F;$GH_TOKEN@$&#123;GH_REF&#125; master:master</span><br><span class="line">  # 如果不习惯这种变量引用，可直接复制粘贴到这，</span><br><span class="line"></span><br><span class="line"># 只有指定的分支提交时才会运行脚本,也就是你要监控的分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - blog</span><br><span class="line"></span><br><span class="line"> #全局可引用变量</span><br><span class="line"> env:</span><br><span class="line"> global:</span><br><span class="line">   - GH_REF ：你的项目github仓库的ssh</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598600138240-ae7cf4c6-6b3f-4b3e-ad09-209632c9dac1.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=355&size=21803&status=done&style=none&width=355" alt="image.png"></p><h4 id="2、加密方法"><a href="#2、加密方法" class="headerlink" title="2、加密方法"></a>2、加密方法</h4><p>此方法需要安装 ruby 环境以及很多东西，可以尝试，但不建议使用，其实就是我觉得麻烦，还不一定配得好。<br>所以这里只列出了大概的.travis.yml 的配置信息，有兴趣的可以百度搜一下这种方法</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置语言及相应版本</span></span><br><span class="line"><span class="symbol">language:</span> node_js</span><br><span class="line"></span><br><span class="line"><span class="symbol">node_js:</span></span><br><span class="line">  - <span class="string">&quot;4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境</span></span><br><span class="line"><span class="symbol">before_install:</span></span><br><span class="line"><span class="comment"># 替换为刚才生成的解密信息</span></span><br><span class="line">- openssl aes-<span class="number">256</span>-cbc -K $encrypted_xxxxxxxxxxxx_key -iv $encrypted_xxxxxxxxxxxx_iv -<span class="keyword">in</span> .travis/id_rsa.enc -out ~<span class="regexp">/.ssh/id</span>_rsa -d</span><br><span class="line"><span class="comment"># 改变文件权限</span></span><br><span class="line">- chmod <span class="number">600</span> ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"><span class="comment"># 配置 ssh</span></span><br><span class="line">- eval $(ssh-agent)</span><br><span class="line">- ssh-add ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line">- cp .travis/ssh_config ~<span class="regexp">/.ssh/config</span></span><br><span class="line"><span class="comment"># 配置 git 替换为自己的信息</span></span><br><span class="line">- git config --global user.name <span class="string">&#x27;yuorname&#x27;</span></span><br><span class="line">- git config --global user.email youremail@xx.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="symbol">install:</span></span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署的命令</span></span><br><span class="line"><span class="symbol">script:</span></span><br><span class="line">- npm run deploy  <span class="comment"># hexo clean &amp;&amp; hexo g -d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目所在分支</span></span><br><span class="line"><span class="symbol">branches:</span></span><br><span class="line">  <span class="symbol">only:</span></span><br><span class="line">  - master</span><br></pre></td></tr></table></figure><h4 id="无论是以上哪种方法，配置完成后，只要我们在修改的分支提交了代码后，就可以在-Travis-Ci-内看到编译以及部署的过程"><a href="#无论是以上哪种方法，配置完成后，只要我们在修改的分支提交了代码后，就可以在-Travis-Ci-内看到编译以及部署的过程" class="headerlink" title="无论是以上哪种方法，配置完成后，只要我们在修改的分支提交了代码后，就可以在 Travis Ci 内看到编译以及部署的过程"></a>无论是以上哪种方法，配置完成后，只要我们在修改的分支提交了代码后，就可以在 Travis Ci 内看到编译以及部署的过程</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598600662273-33958ad7-644d-41ab-91fe-b3cd03108ad8.png#align=left&display=inline&height=570&margin=%5Bobject%20Object%5D&name=image.png&originHeight=570&originWidth=1426&size=81088&status=done&style=none&width=1426" alt="image.png"><br>黄色是正在部署中，绿色是部署成功，红色当然就是失败了！！</p><p>部署完成后，再去 github 的 master 分支，就可以看到 travis ci 它已经自动帮我们将编译后的代码提交到 master 分支了（有一定延迟），然后去我们的博客，刷新一下就可以看到修改了 😸😺😊</p><h3 id="六、问题总结"><a href="#六、问题总结" class="headerlink" title="六、问题总结"></a>六、问题总结</h3><h4 id="1、编译完成后，发现-public-文件夹内就没有生成-index-html-文件"><a href="#1、编译完成后，发现-public-文件夹内就没有生成-index-html-文件" class="headerlink" title="1、编译完成后，发现 public 文件夹内就没有生成 index.html 文件"></a>1、编译完成后，发现 public 文件夹内就没有生成 index.html 文件</h4><p>出现这种问题后，在终端运行<code>npm ls --depth 0</code> 查看 hexo 的各个插件是都安装完成，没有安装完成的安装一下 <code>npm install 插件名 --save</code></p><h4 id="2、编译完成后，生成了-index-html-文件，但是文件为空"><a href="#2、编译完成后，生成了-index-html-文件，但是文件为空" class="headerlink" title="2、编译完成后，生成了 index.html 文件，但是文件为空"></a>2、编译完成后，生成了 index.html 文件，但是文件为空</h4><p>出现这种问题，去检查一下 theme 主题文件夹下你所使用的主题文件内是否还有东西，如果有的话还出现这种问题，建议删除主题后重新 clone 一下（小贴士：刚 clone 的主题记得要去删除里面的.git 文件夹哟）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是 Hexo 这里就不做过多的介绍了，百度一下有很多介绍的&lt;br&gt;这里来介绍一下什么是 Travis CI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、什么是-Travis-CI&quot;&gt;&lt;a href=&quot;#一、什么是-Travis-CI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客实现github部署</title>
    <link href="http://gtliangming.github.io/2020/12/09/ckih06jx60001fanm2st832p3/"/>
    <id>http://gtliangming.github.io/2020/12/09/ckih06jx60001fanm2st832p3/</id>
    <published>2020-12-09T05:45:39.000Z</published>
    <updated>2020-12-09T05:56:16.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、本地创建-Hexo-博客框架"><a href="#一、本地创建-Hexo-博客框架" class="headerlink" title="一、本地创建 Hexo 博客框架"></a>一、本地创建 Hexo 博客框架</h3><p>**</p><h4 id="1、搭建所需环境"><a href="#1、搭建所需环境" class="headerlink" title="1、搭建所需环境"></a>1、搭建所需环境</h4><p><strong>Hexo 官网地址：<a href="https://hexo.io/">https://hexo.io/</a>上都对所需环境、版本信息都做了介绍，这里不过多介绍。</strong><br>**</p><h4 id="2、配置本地仓库与远程仓库的-ssh-key"><a href="#2、配置本地仓库与远程仓库的-ssh-key" class="headerlink" title="2、配置本地仓库与远程仓库的 ssh key"></a>2、配置本地仓库与远程仓库的 ssh key</h4><p>打开终端，输入<code>cd ~/.ssh</code> 查看是否有<code>id_rsa</code> 以及<code>id_rsa.pub</code> 文件，如果有或者自己已经配过。此项可以跳过。如果没有，现在开始创建新的</p><ul><li><p>打开终端，输入<code>cd ~/.ssh</code></p></li><li><p>在 ssh 文件目录下执行 <code>ssh-keygen -t rsa -C “yourname@xx.com</code>   此处的邮箱地址换成你自己的</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598520503078-fefabe3c-1a79-4642-8181-ed53257b0d7d.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=68&originWidth=607&size=83506&status=done&style=none&width=607" alt="image.png"></p><ul><li>点击后，箭头处填写生成的公钥以及私钥的文件名，如果只配置一个 ssh key ,就直接点击回车选择默认，</li><li>接下来的两项也直接回车选择默认</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598520679281-49a1b535-8359-4882-b504-c6cdc70d46ea.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=509&size=500198&status=done&style=none&width=509" alt="image.png"></li></ul><p>这样，SSH key 就生成成功了，现在我们需要使用这个 ssh key</p><ul><li>使用 ssh-agent 代理管理 git 私钥</li></ul><p>添加本地私钥：<code>ssh-add ~/.ssh/刚才生成的公钥的名字</code></p><ul><li>继续在终端输入<code>cat ~/.ssh/刚才生成的公钥的名字</code>（默认是 id_rsa.pub）如果你创建的时候起了别的名字，这里就输入刚才的名字。然后点击回车，终端内就会显示出公钥的内容（很长一段,以 ssh-rsa 开头）</li><li>复制这段信息，打开 github，点击头像选择 setting</li><li>在左边的导航选项内选择<code>SSH and GPG keys</code>选项，选择上面的<code>New SSH key</code></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598521006842-eb0f9a45-2e6f-4d87-a944-fbb893abb3d0.png#align=left&display=inline&height=115&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=795&size=14106&status=done&style=none&width=795" alt="image.png"></p><ul><li>给这个 SSH key 起个名字，以便区分，因为不同的电脑需要配置不同 ssh key，然后将刚才复制的公钥信息粘贴在 key 内，点击 Add ssh key. 这样就配置成功了</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598521113622-875772c9-e7dc-46c8-b84b-e4966e976042.png#align=left&display=inline&height=469&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=824&size=29895&status=done&style=none&width=824" alt="image.png"></li><li>在终端输入<code> ssh -T git@github.com</code> 检测是否配置成功，如下就表示配置成功</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598521331141-0c765591-ce89-472c-8d76-d8019952440c.png#align=left&display=inline&height=37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=37&originWidth=655&size=47981&status=done&style=none&width=655" alt="image.png"></p><blockquote><p>如果中途哪一步出现了问题，可以在.ssh 文件夹下干掉生成的文件，重新开始</p></blockquote><h4 id="3、创建博客仓库"><a href="#3、创建博客仓库" class="headerlink" title="3、创建博客仓库"></a>3、创建博客仓库</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598516924636-5ca5fb75-87f1-4f5b-a160-2f36280d11aa.png#align=left&display=inline&height=568&margin=%5Bobject%20Object%5D&name=image.png&originHeight=756&originWidth=710&size=101157&status=done&style=none&width=533" alt="image.png"><br>点击 Create respository 就创建成功了 😃</p><ul><li>使用 SSH 将项目克隆到本地，并初始化 git 仓库<code>git init </code> 此时默认在<code>master</code> 分支</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/2401896/1598521616753-518b911a-39c0-4c98-8b2f-e239295f9e04.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=542&size=41348&status=done&style=none&width=542" alt="image.png"></p><ul><li>因为 github 部署博客的编译后的代码默认生成到 master 分支，所以我们将项目的源码放置在一个新的<code>blog</code>分支，执行<code>git checkeout -b blog</code> 创建并切换到 blog 分支</li></ul><h3 id="二、生成博客项目"><a href="#二、生成博客项目" class="headerlink" title="二、生成博客项目"></a>二、生成博客项目</h3><h4 id="1、项目生成"><a href="#1、项目生成" class="headerlink" title="1、项目生成"></a>1、项目生成</h4><p>1&gt;、安装生成项目的脚手架工具：<code>npm install hexo-cli -g</code><br>2&gt;、生成项目<code>hexo init 项目名</code></p><h4 id="2、运行项目"><a href="#2、运行项目" class="headerlink" title="2、运行项目"></a>2、运行项目</h4><p>1&gt;、进入到刚才创建的项目下，使用<code>hexo s </code>(hexo server 的缩写)就可启动项目，本地浏览器打开<code>localhost:4000</code>就可查看到我们新创建的 hexo 项目</p><blockquote><p>如果默认的 4000 端口被占用，可使用 hexo s -port 端口号 来启动项目，并在浏览器使用对应的端口来访问</p></blockquote><p>2&gt;、安装完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>其中_config.yml 文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds 是存放模板的文件夹，当新建文章时，Hexo 会根据 scaffold 来建立文件；source 是资源文件夹，用于存放用户资源，themes 是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面</p><h3 id="三、部署到-gtihub"><a href="#三、部署到-gtihub" class="headerlink" title="三、部署到 gtihub"></a>三、部署到 gtihub</h3><p><strong>安装部署到 github 的工具插件：</strong><code>npm install hexo-deployer-git --save</code></p><p>_config.yml 是重要的网站的配置信息，具体配置详见官网<a href="https://hexo.io/docs/configuration">https://hexo.io/docs/configuration</a></p><p>因为我们要将编译后的代码放置在 master 分支下，所以我们需要修改_config.yml 文件下的 deploy</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repo: 存放博客项目的github仓库地址，建议使用ssh地址</span><br><span class="line">  branch: master  需要将博客的代码编译到那个分支，此处就写对应分支的分支名</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完成后，使用 hexo 的命令</p><ol><li><code>hexo clean</code> 清除之前的缓存</li><li><code>hexo generate</code> 编译项目代码</li><li><code>hexo deploy</code> 将编译后的代码根据_congin.yml 内的 deploy 推送到指定仓库的制定分支<blockquote><p>第二步和第三部可以一块 执行 hexo g -d</p></blockquote></li></ol><p>此时就可在<code>https://你的博客仓库名</code> (例如我的<a href="https://gtliangming.github.io/">https://gtliangming.github.io/</a>)查看到你新建的的博客了<br>可能会有一定的延迟，稍等下刷新就有了**</p><p>💐 至此，我们的博客就搭建完成了，至于后面的主题以及美化等的细节问题，期待下一篇吧！！！</p><p>**<br><strong>不知道细心的大家发现了问题了吗？我们博客是更新了，但是我们的本地 blog 分支的代码更新该没有提交，这就表示我们每次执行完 hexo 的命令部署完博客后，还要 Git 三部曲提交我们 blog 分支的代码。好奇的同学就有问题了，能不能一步解决呢，宾果！，关注下一篇哦（Tracis cI 实现自动部署 hexo 博客至 github）</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、本地创建-Hexo-博客框架&quot;&gt;&lt;a href=&quot;#一、本地创建-Hexo-博客框架&quot; class=&quot;headerlink&quot; title=&quot;一、本地创建 Hexo 博客框架&quot;&gt;&lt;/a&gt;一、本地创建 Hexo 博客框架&lt;/h3&gt;&lt;p&gt;**&lt;/p&gt;
&lt;h4 id=</summary>
      
    
    
    
    <category term="hexo" scheme="http://gtliangming.github.io/categories/hexo/"/>
    
    
    <category term="hexo github" scheme="http://gtliangming.github.io/tags/hexo-github/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxh000bfanm0prxfe6x/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxh000bfanm0prxfe6x/</id>
    <published>2020-09-08T08:30:00.000Z</published>
    <updated>2020-10-14T02:25:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1、什么是TypeScript"><a href="#1、什么是TypeScript" class="headerlink" title="1、什么是TypeScript"></a>1、什么是TypeScript</h2><p>typescript是Javascript的一个超集，它也支持ECMAScript 6的标准。</p><p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p><blockquote><p>typescript与javascript的区别</p><p>typescript是Javascript的超集，扩展了Javascript的语法，因此现有的js代码可以与ts一起工作而无需任何修改，ts通过类型注解提供编译时的静态类型检查。</p><p>ts可处理已有的js代码，并且只对其中的ts代码进行编译</p></blockquote><p><strong>TypeScript 转换为 JavaScript 过程如下图：</strong></p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2019/01/typescript_compiler.png" /><h2 id="2、TypeScript的安装"><a href="#2、TypeScript的安装" class="headerlink" title="2、TypeScript的安装"></a>2、TypeScript的安装</h2><p><strong><em>一般使用.ts作为TypeScript文件的后缀名</em></strong></p><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>使用<code>npm install -g typescript</code> 来进行安装</p><p>安装完成后使用<code>tsc -v </code>来进行查看安装是否成功和查看版本</p><h2 id="3、TypeScript的基础语法"><a href="#3、TypeScript的基础语法" class="headerlink" title="3、TypeScript的基础语法"></a>3、TypeScript的基础语法</h2><h4 id="空白和换行"><a href="#空白和换行" class="headerlink" title="空白和换行"></a>空白和换行</h4><p>TypeScript 会忽略程序中出现的空格、制表符和换行符。</p><p>空格、制表符通常用来缩进代码，使代码易于阅读和理解。</p><h4 id="TypeScript-区分大小写"><a href="#TypeScript-区分大小写" class="headerlink" title="TypeScript 区分大小写"></a>TypeScript 区分大小写</h4><p>TypeScript 区分大写和小写字符。</p><h4 id="TypeScript-与面向对象"><a href="#TypeScript-与面向对象" class="headerlink" title="TypeScript 与面向对象"></a>TypeScript 与面向对象</h4><p>面向对象是一种对现实世界理解和抽象的方法。</p><p>TypeScript 是一种面向对象的编程语言。</p><blockquote><p>1、先编写一段ts代码，定义一个luckboy类，它具有一个私有属性方法name</p></blockquote><blockquote><p>2、创建一个这个类的实例newboy来继承这个类的属性和方法</p><p>3、用这个实例调用类里面的name方法</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  lackBoy &#123;</span><br><span class="line">    name():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;luckBoy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> newboy = <span class="keyword">new</span> lackBoy;</span><br><span class="line">newboy.name();</span><br></pre></td></tr></table></figure><blockquote><p>4、使用tsc来对这个ts代码进行转换，转换为js代码(同级目录下出现同名的js文件)</p></blockquote><blockquote><p>5、查看这个js文件,发现创建实例与调用方法没有区别，只是在类的部分有了变化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lackBoy = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lackBoy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    lackBoy.prototype.name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;luckBoy&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> lackBoy;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> newboy = <span class="keyword">new</span> lackBoy;</span><br><span class="line">newboy.name();</span><br></pre></td></tr></table></figure><blockquote><p>6、使用node运行这个js文件，会发现控制台输出luckboy</p></blockquote><h2 id="4、TypeScript的基本类型"><a href="#4、TypeScript的基本类型" class="headerlink" title="4、TypeScript的基本类型"></a>4、TypeScript的基本类型</h2><p><strong>TypeScript包含的所有数据类型如下</strong></p><table><thead><tr><th align="center">数据类型</th><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">任意类型</td><td align="left">any</td><td align="left">声明为 any 的变量可以赋予任意类型的值。</td></tr><tr><td align="center">数字类型</td><td align="left">number</td><td align="left">双精度 64 位浮点值。它可以用来表示整数和分数。</td></tr><tr><td align="center">字符串类型</td><td align="left">string</td><td align="left">一个字符系列，使用单引号（**’<strong>）或双引号（</strong>“<strong>）来表示字符串类型。反引号（</strong>`**）来定义多行文本和内嵌表达式</td></tr><tr><td align="center">布尔类型</td><td align="left">boolean</td><td align="left">表示逻辑值：true 和 false。</td></tr><tr><td align="center">数组类型</td><td align="left">无</td><td align="left">声明变量为数组。                                                                                                       1、在元素类型后面加上[] let arr: number[] = [1, 2];                                          2、或者使用数组泛型 let arr: Array<number> = [1, 2];</td></tr><tr><td align="center">元组类型</td><td align="left">无</td><td align="left">元组类型用来表示已知元素数量和类型的数组，<span style="color:red">各元素的类型不必相同，对应位置的类型需要相同</span>                                                                                                      let x: [string, number];                                                                                                x = [‘Runoob’, 1];    // 运行正常                                                                                        x = [1, ‘Runoob’];    // 报错                                                                       console.log(x[0]);    // 输出 Runoob</td></tr><tr><td align="center">枚举类型</td><td align="left">enum</td><td align="left">枚举类型用于定义数值集合。                                                                                             enum Color {Red, Green, Blue};                                                                                   let c: Color = Color.Blue;                                                                            console.log(c);    // 输出 2</td></tr><tr><td align="center">void类型</td><td align="left">void</td><td align="left">用于标识方法返回值的类型，表示该方法没有返回值。</td></tr><tr><td align="center">null类型</td><td align="left">null</td><td align="left">表示对象值缺失</td></tr><tr><td align="center">undefined类型</td><td align="left">undefined</td><td align="left">用于初始化变量为一个未定义的值</td></tr><tr><td align="center">never类型</td><td align="left">never</td><td align="left">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td></tr></tbody></table><h4 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h4><p> 任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p><ol><li><p>变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查</p></li><li><p>改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时并不会检查所调用的方法是否存在</span></span><br><span class="line"><span class="keyword">let</span> x: any = <span class="number">4</span>;</span><br><span class="line">x.ifItExists();    <span class="comment">// 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span></span><br><span class="line">x.toFixed();    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>定义存储各种类型数据的数组时</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayList: any[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">&#x27;fine&#x27;</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-、TypeScript的变量声明"><a href="#5-、TypeScript的变量声明" class="headerlink" title="5 、TypeScript的变量声明"></a>5 、TypeScript的变量声明</h2><p><strong>1.TypeScript 变量的命名规则：</strong></p><ul><li>变量名称可以包含数字和字母。</li><li>除了下划线 <strong>_</strong> 和美元 <strong>$</strong> 符号外，不能包含其他特殊字符，包括空格。</li><li>变量名不能以数字开头。</li></ul><p>变量使用前必须先声明，我们可以使用 var 来声明变量。</p><p><strong>2.声明TypeScript的变量一般有四种方式</strong></p><ol><li><p>声明变量的类型及初始值：var [变量名] : [类型] = 值;</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> typeName:<span class="built_in">string</span> =<span class="string">&quot;typescript&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>声明变量的类型，但没有初始值，变量值会设置为 undefined</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userNum : <span class="built_in">number</span>; </span><br></pre></td></tr></table></figure></li><li><p>声明变量并初始值，但不设置类型类型，该变量可以是任意类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userID = <span class="number">888</span>;</span><br></pre></td></tr></table></figure></li><li><p>声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userSize;</span><br></pre></td></tr></table></figure></li></ol><p style="color:red">TypeScript 遵循强类型，如果将不同的类型赋值给变量会编译错误</p><p><strong>3.TypeScript变量作用域</strong></p><ul><li><strong>全局作用域</strong> − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li><li><strong>类作用域</strong> − 这个变量也可以称为 <strong>字段</strong>。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li><li><strong>局部作用域</strong> − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;1、什么是TypeScript&quot;&gt;&lt;a href=&quot;#1、什么是T</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxj000cfanm780jgo6q/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxj000cfanm780jgo6q/</id>
    <published>2020-09-08T08:30:00.000Z</published>
    <updated>2020-10-14T02:25:45.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1、TypeScript的函数"><a href="#1、TypeScript的函数" class="headerlink" title="1、TypeScript的函数"></a>1、TypeScript的函数</h2><ul><li><p><strong>TypeScript的可选参数</strong></p><p>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName1</span>(<span class="params">bigTitle1:<span class="built_in">string</span>, smallTitle1:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">//不设置可选参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大标题：&quot;</span>+bigTitle1+<span class="string">&quot;  小标题：&quot;</span>+smallTitle1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setName2</span>(<span class="params">bigTitle2:<span class="built_in">string</span>, smallTitle2?:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">//设置可选参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大标题：&quot;</span>+bigTitle2+<span class="string">&quot;  小标题：&quot;</span>+smallTitle2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(setName1(<span class="string">&quot;哈哈1&quot;</span>,<span class="string">&quot;嘿嘿1&quot;</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(setName1(<span class="string">&quot;哈哈2&quot;</span>))<span class="comment">//typescript编译时就会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(setName2(<span class="string">&quot;哈哈1&quot;</span>,<span class="string">&quot;嘿嘿1&quot;</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(setName2(<span class="string">&quot;哈哈2&quot;</span>))<span class="comment">//不会报错，可以正常编译通过，但是缺少的参数会被赋值为undefined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>TypeScript默认参数</strong></p><p>可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">param1[:<span class="keyword">type</span>],param2[:<span class="keyword">type</span>] = default_value</span>) </span>&#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params">num1:<span class="built_in">number</span>,num2:<span class="built_in">number</span>=0.5</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1+num2)</span><br><span class="line">&#125;</span><br><span class="line">addNum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//输出3</span></span><br><span class="line">addNum(<span class="number">2</span>);<span class="comment">//输出2.5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>TypeScript的剩余参数</strong></p><p>有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。</p><p>剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> setName1 = setName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> i;   </span><br><span class="line">    <span class="keyword">var</span> sum:<span class="built_in">number</span> = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;nums.length;i++) &#123; </span><br><span class="line">       sum = sum + nums[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;和为：&quot;</span>,sum) </span><br><span class="line"> &#125; </span><br><span class="line"> addNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"> addNumbers(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、TypeScript的Number对象"><a href="#2、TypeScript的Number对象" class="headerlink" title="2、TypeScript的Number对象"></a>2、TypeScript的Number对象</h2><ul><li><strong>Number 对象属性</strong></li></ul><table><thead><tr><th align="center">属性</th><th>属性描述</th></tr></thead><tbody><tr><td align="center">MAX_VALUE</td><td>可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”</td></tr><tr><td align="center">MIN_VALUE</td><td>可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0</td></tr><tr><td align="center">NAN</td><td>非数字值（Not-A-Number）</td></tr><tr><td align="center">NEGATIVE_INFINITY</td><td>负无穷大，溢出时返回该值。该值小于 MIN_VALUE。</td></tr><tr><td align="center">POSITIVE_INFINITY</td><td>正无穷大，溢出时返回该值。该值大于 MAX_VALUE。</td></tr><tr><td align="center">prototype</td><td>Number 对象的静态属性。使您有能力向对象添加属性和方法。</td></tr><tr><td align="center">constructor</td><td>返回对创建此对象的 Number 函数的引用。</td></tr></tbody></table><ul><li><strong>Number对象方法</strong></li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>toExponential()</td><td>把对象的值转换为指数计数法。</td></tr><tr><td>toFixed()</td><td>把数字转换为字符串，并对小数点指定位数</td></tr><tr><td>toLocaleString()</td><td>把数字转换为字符串，使用本地数字格式顺序。</td></tr><tr><td>toPrecision()</td><td>把数字格式化为指定的长度。</td></tr><tr><td>toString()</td><td>把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。</td></tr><tr><td>valueOf()</td><td>返回一个 Number 对象的原始数字值。</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toExponential()</span></span><br><span class="line"><span class="keyword">var</span> num1:<span class="built_in">number</span> = <span class="number">12.375</span>;</span><br><span class="line"><span class="keyword">var</span> cNum = num1.toExponential();</span><br><span class="line"><span class="built_in">console</span>.log(cNum);</span><br><span class="line"><span class="comment">//toFixed()</span></span><br><span class="line"><span class="keyword">var</span> num2:<span class="built_in">number</span> = <span class="number">18.656</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed());</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//toLocaleString()</span></span><br><span class="line"><span class="keyword">var</span> num3:<span class="built_in">number</span> = <span class="number">19.33</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num3.toLocaleString());</span><br><span class="line"><span class="comment">//toPrecision()</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">7.123456</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision());  <span class="comment">// 输出：7.123456 </span></span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision(<span class="number">1</span>)); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision(<span class="number">2</span>)); <span class="comment">// 输出：7.1</span></span><br><span class="line"><span class="comment">//toString()</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num5.toString());  <span class="comment">// 输出10进制：10</span></span><br><span class="line"><span class="built_in">console</span>.log(num5.toString(<span class="number">2</span>)); <span class="comment">// 输出2进制：1010</span></span><br><span class="line"><span class="built_in">console</span>.log(num5.toString(<span class="number">8</span>)); <span class="comment">// 输出8进制：12</span></span><br><span class="line"><span class="comment">//valueOf()</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num6.valueOf()); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;1、TypeScript的函数&quot;&gt;&lt;a href=&quot;#1、Type</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>git知识</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxp000mfanmhze1c39e/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxp000mfanmhze1c39e/</id>
    <published>2020-09-08T08:00:58.000Z</published>
    <updated>2020-10-14T02:25:45.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git知识"><a href="#git知识" class="headerlink" title="git知识"></a>git知识</h3><h4 id="一、版本回退"><a href="#一、版本回退" class="headerlink" title="一、版本回退"></a>一、版本回退</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用  git  log 查看commit记录   附带参数：git log --oneline --graph </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEAD表示当前版本   上一个版本就是HEAD^  上上个版本HEAD^^   往上100个版本写HEAD~100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reset --hard  HEAD^ 版本回退至上一个commit</span><br><span class="line"></span><br><span class="line">再次回到之前的版本</span><br><span class="line"> git reset --hard  +commit的id（版本号）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令git reflog用来记录你的每一次命令  包括add checkout  commit等 从中可以查看版本号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在总结一下：</span><br><span class="line">HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</span><br><span class="line">穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br></pre></td></tr></table></figure><h4 id="二、管理修改"><a href="#二、管理修改" class="headerlink" title="二、管理修改"></a>二、管理修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用   git diff HEAD -- 文件名    命令可以查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何丢弃工作区的修改 git checkout -- 文件名</span><br><span class="line"></span><br><span class="line">用命令  git reset HEAD &lt;file&gt;    可以把暂存区的修改撤销掉（unstage）</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line">场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区(git add)时，想丢弃修改，分两步，</span><br><span class="line">    第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line">场景3：已经提交了不合适的修改到版本库(git commit)时，想要撤销本次提交，参考版本回退一节，</span><br><span class="line">    不过前提是没有推送到远程库</span><br></pre></td></tr></table></figure><h4 id="三、删除操作"><a href="#三、删除操作" class="headerlink" title="三、删除操作"></a>三、删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先手动删除文件，然后使用git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的</span><br><span class="line">都是将本地的文件删除，然后也将版本库里面的文件删除</span><br><span class="line"></span><br><span class="line">另一种情况是删错了，还想恢复回来，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</span><br><span class="line">git checkout -- test.txt</span><br><span class="line"></span><br><span class="line">git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br></pre></td></tr></table></figure><h4 id="四-远程仓库"><a href="#四-远程仓库" class="headerlink" title="四 远程仓库"></a>四 远程仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本地仓库关联远程仓库</span><br><span class="line"> git remote add origin 远程仓库地址</span><br><span class="line"> 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</span><br><span class="line"> </span><br><span class="line"> 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，</span><br><span class="line"> 还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge 分支名    命令用于合并指定分支到当前分支</span><br><span class="line">合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，</span><br><span class="line">能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">查看分支：git branch</span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h4 id="六、冲突解决"><a href="#六、冲突解决" class="headerlink" title="六、冲突解决"></a>六、冲突解决</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</span><br><span class="line">解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</span><br><span class="line">用git log --graph命令可以看到分支合并图。</span><br></pre></td></tr></table></figure><h4 id="七、"><a href="#七、" class="headerlink" title="七、"></a>七、</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</span><br><span class="line"></span><br><span class="line">2、用git stash list命令看看</span><br><span class="line"></span><br><span class="line">3、一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</span><br><span class="line"></span><br><span class="line">4、另一种方式是用git stash pop，恢复的同时把stash内容也删了</span><br><span class="line"></span><br><span class="line">5、你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令</span><br><span class="line"> git stash apply stash@&#123;0&#125;</span><br><span class="line"> </span><br><span class="line"> Git专门提供了一个gitcherry-pick命令，让我们能复制一个特定的提交到当前分支：</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">1、修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</span><br><span class="line">2、当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</span><br><span class="line">3、在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，</span><br><span class="line">    把bug提交的修改“复制”到当前分支，避免重复劳动。</span><br></pre></td></tr></table></figure><h4 id="八、"><a href="#八、" class="headerlink" title="八、"></a>八、</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发一个新feature，最好新建一个分支；</span><br><span class="line">如果要丢弃一个没有被合并过的分支，可以通过git branch -D 分支名 强行删除。</span><br></pre></td></tr></table></figure><h4 id="九、多人协作"><a href="#九、多人协作" class="headerlink" title="九、多人协作"></a>九、多人协作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要查看远程库的信息，用  git remote  或者，用git remote -v显示更详细的信息：</span><br><span class="line">显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">1、查看远程库信息，使用git remote -v；</span><br><span class="line">2、本地新建的分支如果不推送到远程，对其他人就是不可见的；</span><br><span class="line">3、从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</span><br><span class="line">4、在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，</span><br><span class="line">    本地和远程分支的名称最好一致；</span><br><span class="line">5、建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin&#x2F;branch-name；</span><br><span class="line">6、从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</span><br></pre></td></tr></table></figure><h4 id="十、Rebase"><a href="#十、Rebase" class="headerlink" title="十、Rebase"></a>十、Rebase</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rebase 做了什么操作呢？</span><br><span class="line">首先， git 会把 feature1 分支里面的每个 commit 取消掉；</span><br><span class="line">其次，把上面的操作临时保存成 patch 文件，存在 .git&#x2F;rebase 目录下；</span><br><span class="line">然后，把 feature1 分支更新到最新的 master 分支；</span><br><span class="line">最后，把上面保存的 patch 文件应用到 feature1 分支上；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br><span class="line">这样 git 会继续应用余下的 patch 补丁文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase —abort</span><br><span class="line">可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git知识&quot;&gt;&lt;a href=&quot;#git知识&quot; class=&quot;headerlink&quot; title=&quot;git知识&quot;&gt;&lt;/a&gt;git知识&lt;/h3&gt;&lt;h4 id=&quot;一、版本回退&quot;&gt;&lt;a href=&quot;#一、版本回退&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="git" scheme="http://gtliangming.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://gtliangming.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Mongodb的安装</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxd0005fanmhxto9a2z/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxd0005fanmhxto9a2z/</id>
    <published>2020-09-08T08:00:00.000Z</published>
    <updated>2020-10-14T02:25:45.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mongodb的安装"><a href="#Mongodb的安装" class="headerlink" title="Mongodb的安装"></a>Mongodb的安装</h2><blockquote><p><code>MongoDB</code> 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 <code>MongoDB</code> 工作在收集和文件的概念。</p></blockquote><h3 id="一、下载方式"><a href="#一、下载方式" class="headerlink" title="一、下载方式"></a>一、下载方式</h3><p>下载MongoDB有三种方式：(具体版本查看官网)</p><p>（1）手动命令安装</p><p>终端运行：<code>curl http://downloads.mongodb.org/osx/mongodb-osx-x86_64-2.4.6.tgz &gt; mongodb.tgz</code></p><p>（2）采用Homebrew</p><p>更新homebrew ：<code>brew update</code></p><p>安装mongodb ：<code>brew install mongodb</code></p><blockquote><p>想安装最新开发版命令 ：<code>brew install mongodb --devel</code></p></blockquote><p>（3）官网下载安装包。</p><p>官网地址 ：<code>https://www.mongodb.com/try?jmp=nav#community</code></p><h3 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h3><h4 id="1、创建MongoDB数据存放的默认文件夹"><a href="#1、创建MongoDB数据存放的默认文件夹" class="headerlink" title="1、创建MongoDB数据存放的默认文件夹"></a>1、创建MongoDB数据存放的默认文件夹</h4><p>MongoDB数据存放的默认路径为/data/db(即根目录下/data/db)，但该目录的文件夹在你电脑不一定存在，执行以下命令创建(你未必有权限创建，所以加上sudo)</p><p><code>sudo mkdir -p /data/db</code></p><blockquote><p>数据库需要读写数据，如果你没root权限，在根目录下创建的文件夹默认是没有写入权限的，直接启动MongoDB会报错</p></blockquote><p>为此文件夹添加读写权限 : <code>sudo chown -R 用户名 /data/db</code></p><h4 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h4><p>打开终端，输入 <code>open -e .bash_profile</code></p><p>在其中添加 <code>export PATH=$&#123;PATH&#125;:/usr/local/MongoDB/bin</code></p><p>用Command+S保存配置，关闭上面的.bash_profile编辑窗口 </p><p>打开终端 输入<code>source .bash_profile</code> 使刚才的配置生效</p><p>然后在终端输入 <code>mongod -version</code> 可以看到版本信息  说明已经安装成功</p><h4 id="3、使用mongodb"><a href="#3、使用mongodb" class="headerlink" title="3、使用mongodb"></a>3、使用mongodb</h4><p>运行mongodb :终端输入 <code>mongod</code> 启动mongob </p><p>显示等候客户端连接的界面就代表启动成功了，如果不成功就检查下 /data/db 文件夹位置对不对，不行就重新删掉建一个， 打开浏览器，输入localhost:27017 ，会出现这样一行文字。</p><blockquote><p>It looks like you are trying to access MongoDB over HTTP on the native driver port</p></blockquote><p>然后再次在终端输入 <code>mongo</code>   开始进入数据库操作</p><h4 id="4、-退出mongodb"><a href="#4、-退出mongodb" class="headerlink" title="4、 退出mongodb"></a>4、 退出mongodb</h4><p>要停止MongoDB的时候一定要正确的退出，不然下次再次连接数据库会出现问题，使用下面的两行代码可以完成这一操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin;</span><br><span class="line"></span><br><span class="line">db.shutdownServer();</span><br></pre></td></tr></table></figure><h3 id="三、可视化数据库工具"><a href="#三、可视化数据库工具" class="headerlink" title="三、可视化数据库工具"></a>三、可视化数据库工具</h3><p>​    Robo 3t</p><p>RoboMongo是一个跨平台的MongoDB GUI客户端管理工具，支持Windows、MacOS、Linux。其特点是支持到MongoDB服务器的SSL连接，还支持使用SSH隧道连接。RoboMongo的查询界面同时支持树视图、表格视图、文本视图三种，也可以保存查询结果供以后使用。</p><p>下载地址 ：<a href="https://robomongo.org/">https://robomongo.org/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mongodb的安装&quot;&gt;&lt;a href=&quot;#Mongodb的安装&quot; class=&quot;headerlink&quot; title=&quot;Mongodb的安装&quot;&gt;&lt;/a&gt;Mongodb的安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt; 是一个跨</summary>
      
    
    
    
    <category term="mongodb" scheme="http://gtliangming.github.io/categories/mongodb/"/>
    
    
    <category term="mongodb" scheme="http://gtliangming.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>将node.js搭建的express项目如何部署到服务器上</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxt000sfanmasgreymx/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxt000sfanmasgreymx/</id>
    <published>2020-09-08T07:30:00.000Z</published>
    <updated>2020-10-14T02:25:45.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将node-js搭建的express项目如何部署到服务器上"><a href="#将node-js搭建的express项目如何部署到服务器上" class="headerlink" title="将node.js搭建的express项目如何部署到服务器上"></a>将node.js搭建的express项目如何部署到服务器上</h2><h3 id="1、所用环境"><a href="#1、所用环境" class="headerlink" title="1、所用环境"></a>1、所用环境</h3><ul><li>node.js </li><li>类似于Zen Term Lite（mac上的）的终端模拟软件 (为什么要用这个，稍后讲)</li><li>已经购买好的云服务器（我是阿里云的）</li><li>宝塔环境</li></ul><h3 id="2、开始部署"><a href="#2、开始部署" class="headerlink" title="2、开始部署"></a>2、开始部署</h3><h4 id="1-第一步-配置自己的云服务器"><a href="#1-第一步-配置自己的云服务器" class="headerlink" title="1. 第一步-配置自己的云服务器"></a>1. 第一步-配置自己的云服务器</h4><p>打开控制台，创建实例（此处划重点！！！牢记密码）</p><p>并且需要记一下自己云服务器的公网地址</p><h4 id="2、给自己的云服务器安装宝塔环境（linux系统）"><a href="#2、给自己的云服务器安装宝塔环境（linux系统）" class="headerlink" title="2、给自己的云服务器安装宝塔环境（linux系统）"></a>2、给自己的云服务器安装宝塔环境（linux系统）</h4><p>下载终端模拟软件，我使用的是xShell，还有好几种，在这里不做赘述</p><p><strong>- 什么是终端模拟软件</strong></p><p>可通过互联网到远程主机的安全连接以及它创新性的设计和特色来帮助用户在极其复杂的网络环境当中进行工作与模拟。</p><p><a href="http://www.xshellcn.com/">Xshell</a>可以直接在Windows界面下访问远程端不同系统下的服务器，从而可让用户更好地进行终端的远程控制.</p><p>Zen Term Lite和xShell功能一样</p><p><strong>- 为什么要用终端模拟软件</strong></p><p>！！！实测，在控制台的远程连接，下载东西巨慢巨慢（也可能是我网不好），其实也是界面看起来让我难受：）</p><p><strong>- 怎么使用</strong></p><ul><li>打开你的云服务器控制台，找到防火墙，在防火墙内添加新的规则</li></ul><ul><li><p>选择一个你喜欢的端口（还是百度一下常用的端口，不要占了默认的端口:（ ）</p></li><li><p>打开终端模拟软件，选择新建一个会话,输入信息</p></li></ul><p>  会话名称：随意，你开心</p><p>  主机地址：刚才的公网地址</p><p>  用户名：一般都是root</p><p>  端口：刚才防火墙开放的端口</p><ul><li>点击连接，会让你输入密码，次密码就是你创建实例的时候的实例密码（也可在属性-认证里面配置密码，以后连接就不让你输入了）</li></ul><h4 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h4><p>1、在连接好的终端内输入</p><p><code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</code></p><p>然后回车下载，等一会~，中途会有一次让你确认一次，无脑y就完事了</p><p>2、下载完成后，就可以看到username 和 password了</p><p>其中也包括宝塔的访问地址 http://你的域名或者ip:8888</p><p>此时宝塔就安装好了</p><h3 id="3、打开宝塔，安装pm2"><a href="#3、打开宝塔，安装pm2" class="headerlink" title="3、打开宝塔，安装pm2"></a>3、打开宝塔，安装pm2</h3><ul><li><p>在文件内找到一个合适的文件夹（建议放在www目录下）上传并解压</p></li><li><p>在软件管理里面找到pm2管理器，安装</p></li><li><p>安装完成后点击设置</p></li></ul><p>​            然后点击添加</p><ul><li>在创建好的项目里可以看到端口号，次端口就是你在自己的node项目内设置的端口号</li><li>点击映射可以用域名来映射项目，访问时直接域名+端口号就可以访问，当然也可以不映射，使用ip来访问也是一样的</li><li>在左侧的选项中，你可以选择适合你的node版本，</li><li>也可在模块管理中安装你所需的模块，我这里安装了express和mongoose（项目里用到了）</li></ul><h3 id="4、再次打开终端模拟软件"><a href="#4、再次打开终端模拟软件" class="headerlink" title="4、再次打开终端模拟软件"></a>4、再次打开终端模拟软件</h3><p>使用<code>node -version</code> 和<code>npm --version</code> 查看是否安装好了node和npm</p><p><strong><em>如果没有版本号显示，你就得给服务器安装node，有的话跳过此项</em></strong></p><p>方法</p><p>在终端内输入ls命令，在home下找到一个合适的文件夹 cd进入</p><ul><li><p>输入<code>wget  https://nodejs.org/dist/v10.15.1/node-v10.15.1-linux-x64.tar.xz</code> 并回车，当然版本与操作系统都是可选的，具体的版本请node官网查看</p></li><li><p>下载完成后将tar.xz 解压成 .tar</p><p><code>xz -d node-v10.15.1-linux-x64.tar.xz</code></p><p>此时的安装包已经变为 <code> node-v10.15.1-linux-x64.tar</code></p></li><li><p>解压tar包</p><p><code>tar -xvf node-v10.15.1-linux-x64.tar </code></p><p>解压完成后在当前路径下会出现 <code> node-v10.15.1-linux-x64</code> 文件夹 就成功了</p><p>记得删除无用的包，减少服务器压力</p></li><li><p>查看bin目录下是否有node以及npm文件夹</p><p>cd进入刚才的<code> node-v10.15.1-linux-x64</code> 文件夹下，找到bin文件并查看是否用node与npm</p></li><li><p>有的话执行软连接</p><p>输入命令 </p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s /路径/bin/npm /usr/<span class="built_in">local</span>/bin/ </span><br><span class="line">ln -s /路径/bin/node /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;software&#x2F;node-v10.15.1-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">ln -s &#x2F;software&#x2F;node-v10.15.1-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li>此时再次使用<code>node -version</code> 和<code>npm --version</code> 查看是否安装好了node和npm，显示版本号就算成功</li></ul><h3 id="5、给自己的项目安装依赖"><a href="#5、给自己的项目安装依赖" class="headerlink" title="5、给自己的项目安装依赖"></a>5、给自己的项目安装依赖</h3><p>打开终端模拟软件，使用ls与cd进入到自己的项目文件夹下</p><p>使用 <code> npm install</code> 将package.json的依赖安装完成</p><p>最后使用 <code>pm2 start ./bin/www</code> 用pm2将自己的项目跑起来</p><h4 id="6、配置端口"><a href="#6、配置端口" class="headerlink" title="6、配置端口"></a>6、配置端口</h4><p>打开宝塔，在最左侧找到安全组 开放3000至3500的端口（端口范围3000:3500），点击放行</p><p>再打开你的服务器控制台，在防火墙内添加新的规则，开放3000至3500的端口（端口范围3000/3500）  点击添加</p><h4 id="7、最后一步，重新启动项目"><a href="#7、最后一步，重新启动项目" class="headerlink" title="7、最后一步，重新启动项目"></a>7、最后一步，重新启动项目</h4><p>再次在终端内使用ls+cd到你的项目目录下</p><p>使用 <code> pm2 restart ./bin/www</code>  此时你的node项目就已经部署到服务器上了</p><p>可以使用ip+端口号+你定义的路由 就可以访问你写好的接口了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将node-js搭建的express项目如何部署到服务器上&quot;&gt;&lt;a href=&quot;#将node-js搭建的express项目如何部署到服务器上&quot; class=&quot;headerlink&quot; title=&quot;将node.js搭建的express项目如何部署到服务器上&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="node.js" scheme="http://gtliangming.github.io/categories/node-js/"/>
    
    
    <category term="node.js express 服务器部署" scheme="http://gtliangming.github.io/tags/node-js-express-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>WebPack的配置(二)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxn000ifanm29ao6b78/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxn000ifanm29ao6b78/</id>
    <published>2020-09-08T07:05:00.000Z</published>
    <updated>2020-12-09T05:59:34.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack-config-js-二"><a href="#webpack-config-js-二" class="headerlink" title="webpack.config.js(二)"></a>webpack.config.js(二)</h2><p>之前说到了打包模式(mode)、出入口文件(entry &amp; output)、模块(model)的配置以及注意事项 </p><p><a href="https://www.tapd.cn/20278041/markdown_wikis/#1120278041001077808@toc0">传送门：webpck.config.js(一)</a></p><p>这次来说接下来的插件(plugins)</p><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h3><p><strong>插件</strong>是 webpack 的 <a href="https://github.com/webpack/tapable">支柱</a> 功能。webpack 自身也是构建于你在 webpack 配置中用到的<strong>相同的插件系统</strong>之上！</p><p>插件目的在于解决 <a href="https://webpack.docschina.org/concepts/loaders">loader</a> 无法实现的<strong>其他事</strong>。</p><p>用法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ProgressPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常用的插件</p><h4 id="一、HTMLWebpackPlugin基本作用就是生成html文件。"><a href="#一、HTMLWebpackPlugin基本作用就是生成html文件。" class="headerlink" title="一、HTMLWebpackPlugin基本作用就是生成html文件。"></a>一、HTMLWebpackPlugin基本作用就是生成html文件。</h4><p><code>HTMLWebpackPlugin</code>的一个实例生成一个html文件，如果单页应用中需要多个页面入口，或者多页应用时配置多个html时，那么就需要实例化该插件多次；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">template: <span class="string">&quot;./src/assets/ejs/template.ejs&quot;</span>,</span><br><span class="line">inject: <span class="string">&quot;body&quot;</span>,</span><br><span class="line">inlineSource: <span class="string">&quot;runtime~main.*js$&quot;</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>原理：将 webpack中<code>entry</code>配置的相关入口chunk  和  <code>extract-text-webpack-plugin</code>抽取的css样式   插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个html文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p><h4 id="二、HotModuleReplacementPlugin"><a href="#二、HotModuleReplacementPlugin" class="headerlink" title="二、HotModuleReplacementPlugin"></a>二、HotModuleReplacementPlugin</h4><p>热模块替换（HMR）是webpack提供的最有用的特性之一，热模块替换可以让模块在没有页面刷新的情况下实时更新代码改动结果；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码配置中需要注意地方：<br> 如果已经通过 <a href="https://www.webpackjs.com/plugins/hot-module-replacement-plugin"><code>HotModuleReplacementPlugin</code></a> 启用了<a href="https://www.webpackjs.com/concepts/hot-module-replacement">模块热替换(Hot Module Replacement)</a>，则它的接口将被暴露在 <a href="https://www.webpackjs.com/api/module-variables#module-hot-webpack-specific-"><code>module.hot</code> 属性</a>下面。通常，用户先要检查这个接口是否可访问，然后再开始使用它</p></blockquote><p><strong><em>在你的代码中插入热替换代码</em></strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口文件结尾处插入</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只有被 “accept”的代码模块才会被热更新，所以你需要在父节点或者父节点的父节点… module.hot.accept 调用模块。如以上代码所示，在入口文件加入 module.hot.accept之后在入口文件引用的任何子模块更新都会触发热更新。模块更新完成，浏览器会输出类型以下信息</p></blockquote><p>![image-20200924182054973](/Users/lt/Library/Application Support/typora-user-images/image-20200924182054973.png)</p><p><strong><em>也可以像官方提供的实例一样accept特定的模块，</em></strong></p><p><strong><em>如下举个栗子🌰</em></strong>  —&gt;例如在M站的Frame.tsx内。当’./app’有任何更新是都会触发热模块更新</p><p>![image-20200924181939409](/Users/lt/Library/Application Support/typora-user-images/image-20200924181939409.png)</p><p><a href="https://github.com/webpack/docs/wiki/hot-module-replacement-with-webpack">更多Hot Module Replacement资料参考</a></p><h4 id="三、DefinePlugin"><a href="#三、DefinePlugin" class="headerlink" title="三、DefinePlugin"></a>三、DefinePlugin</h4><p><code>DefinePlugin</code>是一个设置全局变量的插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再举个栗子🌰 M站webpack.config.js 146~151</span></span><br><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line"><span class="string">&quot;process.env.NODE_ENV&quot;</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">__DEV__: isDev,</span><br><span class="line">IS_SSR: <span class="built_in">JSON</span>.stringify(<span class="literal">false</span>),</span><br><span class="line">IS_FRAME_ONLY: <span class="built_in">JSON</span>.stringify(<span class="literal">false</span>)</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// M-SSR next.config.js 23-26</span></span><br><span class="line"> <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">__SERVER__: isServer,</span><br><span class="line">IS_FRAME_ONLY: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过DefinePlugin定义的变量可在全局代码中使用，例如Webpack配置文件定义了<em>SERVER</em>= isServer，如果代码中存在如下调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(_SERVER_ !== isServer))&#123;<span class="built_in">console</span>.log(<span class="number">1111</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（<span class="literal">false</span>）&#123;<span class="built_in">console</span>.log(<span class="number">11111</span>)&#125;</span><br></pre></td></tr></table></figure><p><strong>插件原理：DefinePlugin做的工作是在源代码基础上执行的全局查找替换工作，将DefinePlugin插件中定义的变量替换为插件中定义的变量值。</strong></p><p><a href="https://link.jianshu.com/?t=https://webpack.js.org/plugins/define-plugin">更多 DefinePlugin资料参考</a></p><h4 id="四、ProvidePlugin"><a href="#四、ProvidePlugin" class="headerlink" title="四、ProvidePlugin"></a>四、ProvidePlugin</h4><p>自动加载模块，而不必到处 <code>import</code> 或 <code>require</code>  </p><p>例如我们要使用jquery</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">  jQuery: <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">然后在代码任意地方</span><br><span class="line">$(<span class="string">&quot;#test&quot;</span>)</span><br><span class="line">jQuery(<span class="string">&quot;#test&quot;</span>)  这两种都可以实现jquery的用法</span><br></pre></td></tr></table></figure><h4 id="五、CleanWebpackPlugin"><a href="#五、CleanWebpackPlugin" class="headerlink" title="五、CleanWebpackPlugin"></a>五、CleanWebpackPlugin</h4><p>作用： 当我们打包好一个文件生成了对应的bundle文件 ，但当文件改变时又会生成一个新的bundle文件，之前的就没有用了，但是没有删除，增加了代码的负重。所以就要使用CleanWebpackPlugin插件来删除那些旧的无用的bundle文件，只保留最新的</p><p>安装 <code> npm i clean-webpack-plugin --save-dev</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// webpack4.0默认文件夹为dist</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webpack-config-js-二&quot;&gt;&lt;a href=&quot;#webpack-config-js-二&quot; class=&quot;headerlink&quot; title=&quot;webpack.config.js(二)&quot;&gt;&lt;/a&gt;webpack.config.js(二)&lt;/h2&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/categories/WebPack/"/>
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>WebPack的配置(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckih06jxl000gfanm0h8i2btp/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckih06jxl000gfanm0h8i2btp/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-12-09T05:57:42.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、webpack-config-js"><a href="#一、webpack-config-js" class="headerlink" title="一、webpack.config.js"></a>一、webpack.config.js</h3><h4 id="1、打包模式-mode"><a href="#1、打包模式-mode" class="headerlink" title="1、打包模式 mode"></a>1、打包模式 mode</h4><p>在打包时配置mode是为了告知 webpack 使用相应模式的内置优化</p><p>mode的模式分别有三种：we</p><ul><li>Production   生产环境打包 默认值</li><li>Development  开发环境打包</li><li>None  不使用任何默认优化选项</li></ul><p>Production与Development的区别：</p><ul><li>生产模式会把打包好后的代码进行压缩，可阅读性不好，但是代码体积小</li><li>开发模式不会压缩代码，可阅读性好，但是代码体积大</li><li>开发模式一些没有依赖的方法 变量 文件会保留，生产模式会移除</li></ul><h4 id="2、入口-entry"><a href="#2、入口-entry" class="headerlink" title="2、入口  entry"></a>2、入口  entry</h4><p>入口起点告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的文件内容</p><p><code>entry</code>接受三种形式的值：字符串，数组和对象</p><ul><li><p>对象</p><p>基本形式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entyr:&#123;</span><br><span class="line">&lt;key&gt;:<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 每一个属性对都对应一个入口文件，适合多页面打包配置</span></span><br></pre></td></tr></table></figure></li></ul><p>   <strong>key的值可以为比较简单的字符串，此时key对应出口文件output.filename配置中的[name]变量</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如 </span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;app-entry&#x27;</span>: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的app-entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>key的值也可以为路径字符串，此时webpack会自动生成路径目录，并将路径的最后作为[name]</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;/example/entry&#x27;</span>: <span class="string">&#x27;./deep-app.js&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的example文件夹下的entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>value如果是字符串，那就必须是合理的node require函数参数字符串。</strong></p><p>  <strong>比如文件路径：’./app.js’       (require(‘./app.js’))；</strong></p><p>  <strong>比如安装的npm模块：’lodash’       (require(‘lodash’))</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;my-lodash&#x27;</span>: <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./output&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>value如果是数组，则数组中元素需要是上面描述的合理字符串值。数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    vendor: [<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串</p><p><code>entry: &#39;./app.js&#39;</code>  等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组</p><p><code>entry: [&#39;./index.js&#39;, &#39;lodash&#39;]</code> 等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: [<span class="string">&#x27;./app.js&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、出口-output"><a href="#3、出口-output" class="headerlink" title="3、出口 output"></a>3、出口 output</h4><p>告诉webpack怎样存储输出结果以及存储到哪里,指定每个输出文件的名称。在这里不能指定为绝对路径！</p><p>基本形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">path:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  publicPath:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  filename:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// path:所有输出文件的目标路径;打包后文件在硬盘中的存储位置。</span></span><br><span class="line"><span class="comment">// publicPath:输出解析文件的目录，指定资源文件引用的目录 ，打包后浏览器访问服务时的 url 路径中通用的一部分。</span></span><br></pre></td></tr></table></figure><ul><li><p>Path 仅仅告诉Webpack结果存储在哪里</p></li><li><p>publicPath 用于在生产模式下更新内嵌到css、html文件里的url值</p><p><strong>output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误</strong></p></li></ul><p>注 ：在使用html-webpack-plugin 生成index.html时，publicPath是可以不用配置的。</p><p>​    <strong>output的输出hash值</strong></p><ul><li><p>[hash] </p><p>每个文件的hash都一样，文件的hash为打包的hash。</p></li><li><p>[chunkhash] </p><p>使用文件的hash都不一样，也与打包hash不一样</p></li></ul><h4 id="4、-模块"><a href="#4、-模块" class="headerlink" title="4、 模块"></a>4、 模块</h4><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块。每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p><ul><li><p>配置 Loader</p><p>rules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 <code>rules</code> 时大致通过以下方式：</p><ol><li>条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。</li><li>应用规则：对选中后的文件通过 <code>use</code> 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。</li><li>重置顺序：一组 Loader 的执行顺序默认是从右到左执行，通过 <code>enforce</code> 选项可以让其中一个 Loader 的执行顺序放到最前或者最后</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 css 文件</span></span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 用 babel-loader 转换 css 文件</span></span><br><span class="line">      <span class="comment">// ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度</span></span><br><span class="line">      use: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">      <span class="comment">// 只命中src目录里的js文件，加快 Webpack 搜索速度</span></span><br><span class="line">      include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 SCSS 文件</span></span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 使用一组 Loader 去处理 SCSS 文件。</span></span><br><span class="line">      <span class="comment">// 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。</span></span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">      <span class="comment">// 排除 node_modules 目录下的文件</span></span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 对GIF、PNG等的文件采用 file-loader 加载</span></span><br><span class="line">      test: <span class="regexp">/\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;file-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Loader 需要传入很多参数时，你还可以通过一个 对象 来描述</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      cacheDirectory:<span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// enforce:&#x27;post&#x27; 的含义是把该 Loader 的执行顺序放到最后</span></span><br><span class="line">    <span class="comment">// enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面</span></span><br><span class="line">    enforce:<span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中的test、include、exclude都可以传入数组，数组里的每项之间是或的关系，即文件路径符合数组中的任何一个条件就会被命中</p><ul><li>配置 noParse</li></ul><p><code>noParse</code> 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能。 原因是一些库例如 jQuery 、ChartJS 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p><p><code>noParse</code> 是可选配置项，类型需要是 <code>RegExp</code>、<code>[RegExp]</code>、<code>function</code> 其中一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line">noParse: <span class="regexp">/jquery|chartjs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数，从 Webpack 3.0.0 开始支持</span></span><br><span class="line">noParse: <span class="function">(<span class="params">content</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// content 代表一个模块的文件路径</span></span><br><span class="line">  <span class="comment">// 返回 true or false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/jquery|chartjs/</span>.test(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。</span></span><br></pre></td></tr></table></figure><ul><li>配置 parser</li></ul><p>因为 Webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能，支持 AMD、CommonJS、SystemJS、ES6。 <code>parser</code> 属性可以更细粒度的配置哪些模块语法要解析哪些不解析，和 <code>noParse</code> 配置项的区别在于 <code>parser</code> 可以精确到语法层面， 而 noParse 只能控制哪些文件不被解析。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;style&quot;</span>, <span class="string">&quot;css&quot;</span>, <span class="string">&quot;postcss&quot;</span>],</span><br><span class="line">      parser: &#123;</span><br><span class="line">        amd: <span class="literal">false</span>, <span class="comment">// 禁用 AMD</span></span><br><span class="line">        commonjs: <span class="literal">false</span>, <span class="comment">// 禁用 CommonJS</span></span><br><span class="line">        system: <span class="literal">false</span>, <span class="comment">// 禁用 SystemJS</span></span><br><span class="line">        harmony: <span class="literal">false</span>, <span class="comment">// 禁用 ES6 import/export</span></span><br><span class="line">        requireInclude: <span class="literal">false</span>, <span class="comment">// 禁用 require.include</span></span><br><span class="line">        requireEnsure: <span class="literal">false</span>, <span class="comment">// 禁用 require.ensure</span></span><br><span class="line">        requireContext: <span class="literal">false</span>, <span class="comment">// 禁用 require.context</span></span><br><span class="line">        browserify: <span class="literal">false</span>, <span class="comment">// 禁用 browserify</span></span><br><span class="line">        requireJs: <span class="literal">false</span>, <span class="comment">// 禁用 requirejs</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、webpack-config-js&quot;&gt;&lt;a href=&quot;#一、webpack-config-js&quot; class=&quot;headerlink&quot; title=&quot;一、webpack.config.js&quot;&gt;&lt;/a&gt;一、webpack.config.js&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/categories/WebPack/"/>
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/tags/WebPack/"/>
    
  </entry>
  
</feed>

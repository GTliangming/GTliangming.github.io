<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小明同学的博客</title>
  
  
  <link href="http://gtliangming.github.io/atom.xml" rel="self"/>
  
  <link href="http://gtliangming.github.io/"/>
  <updated>2020-09-08T09:10:35.144Z</updated>
  <id>http://gtliangming.github.io/</id>
  
  <author>
    <name>Bruce Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo搭建博客实现github部署</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc37c0000atnm964h3fan/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc37c0000atnm964h3fan/</id>
    <published>2020-09-08T08:32:55.000Z</published>
    <updated>2020-09-08T09:10:35.144Z</updated>
    
    
    
    
    <category term="hexo" scheme="http://gtliangming.github.io/categories/hexo/"/>
    
    
    <category term="hexo github" scheme="http://gtliangming.github.io/tags/hexo-github/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc37r0001atnm1ciqa4v1/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc37r0001atnm1ciqa4v1/</id>
    <published>2020-09-08T08:30:00.000Z</published>
    <updated>2020-09-08T09:10:16.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1、什么是TypeScript"><a href="#1、什么是TypeScript" class="headerlink" title="1、什么是TypeScript"></a>1、什么是TypeScript</h2><p>typescript是Javascript的一个超集，它也支持ECMAScript 6的标准。</p><p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p><blockquote><p>typescript与javascript的区别</p><p>typescript是Javascript的超集，扩展了Javascript的语法，因此现有的js代码可以与ts一起工作而无需任何修改，ts通过类型注解提供编译时的静态类型检查。</p><p>ts可处理已有的js代码，并且只对其中的ts代码进行编译</p></blockquote><p><strong>TypeScript 转换为 JavaScript 过程如下图：</strong></p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2019/01/typescript_compiler.png" /><h2 id="2、TypeScript的安装"><a href="#2、TypeScript的安装" class="headerlink" title="2、TypeScript的安装"></a>2、TypeScript的安装</h2><p><strong><em>一般使用.ts作为TypeScript文件的后缀名</em></strong></p><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>使用<code>npm install -g typescript</code> 来进行安装</p><p>安装完成后使用<code>tsc -v </code>来进行查看安装是否成功和查看版本</p><h2 id="3、TypeScript的基础语法"><a href="#3、TypeScript的基础语法" class="headerlink" title="3、TypeScript的基础语法"></a>3、TypeScript的基础语法</h2><h4 id="空白和换行"><a href="#空白和换行" class="headerlink" title="空白和换行"></a>空白和换行</h4><p>TypeScript 会忽略程序中出现的空格、制表符和换行符。</p><p>空格、制表符通常用来缩进代码，使代码易于阅读和理解。</p><h4 id="TypeScript-区分大小写"><a href="#TypeScript-区分大小写" class="headerlink" title="TypeScript 区分大小写"></a>TypeScript 区分大小写</h4><p>TypeScript 区分大写和小写字符。</p><h4 id="TypeScript-与面向对象"><a href="#TypeScript-与面向对象" class="headerlink" title="TypeScript 与面向对象"></a>TypeScript 与面向对象</h4><p>面向对象是一种对现实世界理解和抽象的方法。</p><p>TypeScript 是一种面向对象的编程语言。</p><blockquote><p>1、先编写一段ts代码，定义一个luckboy类，它具有一个私有属性方法name</p></blockquote><blockquote><p>2、创建一个这个类的实例newboy来继承这个类的属性和方法</p><p>3、用这个实例调用类里面的name方法</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  lackBoy &#123;</span><br><span class="line">    name():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;luckBoy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> newboy = <span class="keyword">new</span> lackBoy;</span><br><span class="line">newboy.name();</span><br></pre></td></tr></table></figure><blockquote><p>4、使用tsc来对这个ts代码进行转换，转换为js代码(同级目录下出现同名的js文件)</p></blockquote><blockquote><p>5、查看这个js文件,发现创建实例与调用方法没有区别，只是在类的部分有了变化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lackBoy = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lackBoy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    lackBoy.prototype.name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;luckBoy&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> lackBoy;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> newboy = <span class="keyword">new</span> lackBoy;</span><br><span class="line">newboy.name();</span><br></pre></td></tr></table></figure><blockquote><p>6、使用node运行这个js文件，会发现控制台输出luckboy</p></blockquote><h2 id="4、TypeScript的基本类型"><a href="#4、TypeScript的基本类型" class="headerlink" title="4、TypeScript的基本类型"></a>4、TypeScript的基本类型</h2><p><strong>TypeScript包含的所有数据类型如下</strong></p><table><thead><tr><th align="center">数据类型</th><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">任意类型</td><td align="left">any</td><td align="left">声明为 any 的变量可以赋予任意类型的值。</td></tr><tr><td align="center">数字类型</td><td align="left">number</td><td align="left">双精度 64 位浮点值。它可以用来表示整数和分数。</td></tr><tr><td align="center">字符串类型</td><td align="left">string</td><td align="left">一个字符系列，使用单引号（**’<strong>）或双引号（</strong>“<strong>）来表示字符串类型。反引号（</strong>`**）来定义多行文本和内嵌表达式</td></tr><tr><td align="center">布尔类型</td><td align="left">boolean</td><td align="left">表示逻辑值：true 和 false。</td></tr><tr><td align="center">数组类型</td><td align="left">无</td><td align="left">声明变量为数组。                                                                                                       1、在元素类型后面加上[] let arr: number[] = [1, 2];                                          2、或者使用数组泛型 let arr: Array<number> = [1, 2];</td></tr><tr><td align="center">元组类型</td><td align="left">无</td><td align="left">元组类型用来表示已知元素数量和类型的数组，<span style="color:red">各元素的类型不必相同，对应位置的类型需要相同</span>                                                                                                      let x: [string, number];                                                                                                x = [‘Runoob’, 1];    // 运行正常                                                                                        x = [1, ‘Runoob’];    // 报错                                                                       console.log(x[0]);    // 输出 Runoob</td></tr><tr><td align="center">枚举类型</td><td align="left">enum</td><td align="left">枚举类型用于定义数值集合。                                                                                             enum Color {Red, Green, Blue};                                                                                   let c: Color = Color.Blue;                                                                            console.log(c);    // 输出 2</td></tr><tr><td align="center">void类型</td><td align="left">void</td><td align="left">用于标识方法返回值的类型，表示该方法没有返回值。</td></tr><tr><td align="center">null类型</td><td align="left">null</td><td align="left">表示对象值缺失</td></tr><tr><td align="center">undefined类型</td><td align="left">undefined</td><td align="left">用于初始化变量为一个未定义的值</td></tr><tr><td align="center">never类型</td><td align="left">never</td><td align="left">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td></tr></tbody></table><h4 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h4><p> 任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p><ol><li><p>变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查</p></li><li><p>改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时并不会检查所调用的方法是否存在</span></span><br><span class="line"><span class="keyword">let</span> x: any = <span class="number">4</span>;</span><br><span class="line">x.ifItExists();    <span class="comment">// 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span></span><br><span class="line">x.toFixed();    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>定义存储各种类型数据的数组时</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayList: any[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">&#x27;fine&#x27;</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-、TypeScript的变量声明"><a href="#5-、TypeScript的变量声明" class="headerlink" title="5 、TypeScript的变量声明"></a>5 、TypeScript的变量声明</h2><p><strong>1.TypeScript 变量的命名规则：</strong></p><ul><li>变量名称可以包含数字和字母。</li><li>除了下划线 <strong>_</strong> 和美元 <strong>$</strong> 符号外，不能包含其他特殊字符，包括空格。</li><li>变量名不能以数字开头。</li></ul><p>变量使用前必须先声明，我们可以使用 var 来声明变量。</p><p><strong>2.声明TypeScript的变量一般有四种方式</strong></p><ol><li><p>声明变量的类型及初始值：var [变量名] : [类型] = 值;</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> typeName:<span class="built_in">string</span> =<span class="string">&quot;typescript&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>声明变量的类型，但没有初始值，变量值会设置为 undefined</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userNum : <span class="built_in">number</span>; </span><br></pre></td></tr></table></figure></li><li><p>声明变量并初始值，但不设置类型类型，该变量可以是任意类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userID = <span class="number">888</span>;</span><br></pre></td></tr></table></figure></li><li><p>声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userSize;</span><br></pre></td></tr></table></figure></li></ol><p style="color:red">TypeScript 遵循强类型，如果将不同的类型赋值给变量会编译错误</p><p><strong>3.TypeScript变量作用域</strong></p><ul><li><strong>全局作用域</strong> − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li><li><strong>类作用域</strong> − 这个变量也可以称为 <strong>字段</strong>。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li><li><strong>局部作用域</strong> − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;1、什么是TypeScript&quot;&gt;&lt;a href=&quot;#1、什么是T</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc37y0005atnm7udp6qgf/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc37y0005atnm7udp6qgf/</id>
    <published>2020-09-08T08:30:00.000Z</published>
    <updated>2020-09-08T09:10:08.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1、TypeScript的函数"><a href="#1、TypeScript的函数" class="headerlink" title="1、TypeScript的函数"></a>1、TypeScript的函数</h2><ul><li><p><strong>TypeScript的可选参数</strong></p><p>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName1</span>(<span class="params">bigTitle1:<span class="built_in">string</span>, smallTitle1:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">//不设置可选参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大标题：&quot;</span>+bigTitle1+<span class="string">&quot;  小标题：&quot;</span>+smallTitle1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setName2</span>(<span class="params">bigTitle2:<span class="built_in">string</span>, smallTitle2?:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">//设置可选参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大标题：&quot;</span>+bigTitle2+<span class="string">&quot;  小标题：&quot;</span>+smallTitle2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(setName1(<span class="string">&quot;哈哈1&quot;</span>,<span class="string">&quot;嘿嘿1&quot;</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(setName1(<span class="string">&quot;哈哈2&quot;</span>))<span class="comment">//typescript编译时就会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(setName2(<span class="string">&quot;哈哈1&quot;</span>,<span class="string">&quot;嘿嘿1&quot;</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(setName2(<span class="string">&quot;哈哈2&quot;</span>))<span class="comment">//不会报错，可以正常编译通过，但是缺少的参数会被赋值为undefined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>TypeScript默认参数</strong></p><p>可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">param1[:<span class="keyword">type</span>],param2[:<span class="keyword">type</span>] = default_value</span>) </span>&#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params">num1:<span class="built_in">number</span>,num2:<span class="built_in">number</span>=0.5</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1+num2)</span><br><span class="line">&#125;</span><br><span class="line">addNum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//输出3</span></span><br><span class="line">addNum(<span class="number">2</span>);<span class="comment">//输出2.5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>TypeScript的剩余参数</strong></p><p>有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。</p><p>剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> setName1 = setName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> i;   </span><br><span class="line">    <span class="keyword">var</span> sum:<span class="built_in">number</span> = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;nums.length;i++) &#123; </span><br><span class="line">       sum = sum + nums[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;和为：&quot;</span>,sum) </span><br><span class="line"> &#125; </span><br><span class="line"> addNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"> addNumbers(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、TypeScript的Number对象"><a href="#2、TypeScript的Number对象" class="headerlink" title="2、TypeScript的Number对象"></a>2、TypeScript的Number对象</h2><ul><li><strong>Number 对象属性</strong></li></ul><table><thead><tr><th align="center">属性</th><th>属性描述</th></tr></thead><tbody><tr><td align="center">MAX_VALUE</td><td>可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”</td></tr><tr><td align="center">MIN_VALUE</td><td>可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0</td></tr><tr><td align="center">NAN</td><td>非数字值（Not-A-Number）</td></tr><tr><td align="center">NEGATIVE_INFINITY</td><td>负无穷大，溢出时返回该值。该值小于 MIN_VALUE。</td></tr><tr><td align="center">POSITIVE_INFINITY</td><td>正无穷大，溢出时返回该值。该值大于 MAX_VALUE。</td></tr><tr><td align="center">prototype</td><td>Number 对象的静态属性。使您有能力向对象添加属性和方法。</td></tr><tr><td align="center">constructor</td><td>返回对创建此对象的 Number 函数的引用。</td></tr></tbody></table><ul><li><strong>Number对象方法</strong></li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>toExponential()</td><td>把对象的值转换为指数计数法。</td></tr><tr><td>toFixed()</td><td>把数字转换为字符串，并对小数点指定位数</td></tr><tr><td>toLocaleString()</td><td>把数字转换为字符串，使用本地数字格式顺序。</td></tr><tr><td>toPrecision()</td><td>把数字格式化为指定的长度。</td></tr><tr><td>toString()</td><td>把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。</td></tr><tr><td>valueOf()</td><td>返回一个 Number 对象的原始数字值。</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toExponential()</span></span><br><span class="line"><span class="keyword">var</span> num1:<span class="built_in">number</span> = <span class="number">12.375</span>;</span><br><span class="line"><span class="keyword">var</span> cNum = num1.toExponential();</span><br><span class="line"><span class="built_in">console</span>.log(cNum);</span><br><span class="line"><span class="comment">//toFixed()</span></span><br><span class="line"><span class="keyword">var</span> num2:<span class="built_in">number</span> = <span class="number">18.656</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed());</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num2.toFixed(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//toLocaleString()</span></span><br><span class="line"><span class="keyword">var</span> num3:<span class="built_in">number</span> = <span class="number">19.33</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num3.toLocaleString());</span><br><span class="line"><span class="comment">//toPrecision()</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">7.123456</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision());  <span class="comment">// 输出：7.123456 </span></span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision(<span class="number">1</span>)); <span class="comment">// 输出：7</span></span><br><span class="line"><span class="built_in">console</span>.log(num4.toPrecision(<span class="number">2</span>)); <span class="comment">// 输出：7.1</span></span><br><span class="line"><span class="comment">//toString()</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num5.toString());  <span class="comment">// 输出10进制：10</span></span><br><span class="line"><span class="built_in">console</span>.log(num5.toString(<span class="number">2</span>)); <span class="comment">// 输出2进制：1010</span></span><br><span class="line"><span class="built_in">console</span>.log(num5.toString(<span class="number">8</span>)); <span class="comment">// 输出8进制：12</span></span><br><span class="line"><span class="comment">//valueOf()</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>); </span><br><span class="line"><span class="built_in">console</span>.log(num6.valueOf()); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;1、TypeScript的函数&quot;&gt;&lt;a href=&quot;#1、Type</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="http://gtliangming.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>git知识</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc383000batnmd4t06at1/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc383000batnmd4t06at1/</id>
    <published>2020-09-08T08:00:58.000Z</published>
    <updated>2020-09-08T09:15:24.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git知识"><a href="#git知识" class="headerlink" title="git知识"></a>git知识</h3><h4 id="一、版本回退"><a href="#一、版本回退" class="headerlink" title="一、版本回退"></a>一、版本回退</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用  git  log 查看commit记录   附带参数：git log --oneline --graph </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEAD表示当前版本   上一个版本就是HEAD^  上上个版本HEAD^^   往上100个版本写HEAD~100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reset --hard  HEAD^ 版本回退至上一个commit</span><br><span class="line"></span><br><span class="line">再次回到之前的版本</span><br><span class="line"> git reset --hard  +commit的id（版本号）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令git reflog用来记录你的每一次命令  包括add checkout  commit等 从中可以查看版本号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在总结一下：</span><br><span class="line">HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</span><br><span class="line">穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br></pre></td></tr></table></figure><h4 id="二、管理修改"><a href="#二、管理修改" class="headerlink" title="二、管理修改"></a>二、管理修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用   git diff HEAD -- 文件名    命令可以查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何丢弃工作区的修改 git checkout -- 文件名</span><br><span class="line"></span><br><span class="line">用命令  git reset HEAD &lt;file&gt;    可以把暂存区的修改撤销掉（unstage）</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line">场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区(git add)时，想丢弃修改，分两步，</span><br><span class="line">    第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line">场景3：已经提交了不合适的修改到版本库(git commit)时，想要撤销本次提交，参考版本回退一节，</span><br><span class="line">    不过前提是没有推送到远程库</span><br></pre></td></tr></table></figure><h4 id="三、删除操作"><a href="#三、删除操作" class="headerlink" title="三、删除操作"></a>三、删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先手动删除文件，然后使用git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的</span><br><span class="line">都是将本地的文件删除，然后也将版本库里面的文件删除</span><br><span class="line"></span><br><span class="line">另一种情况是删错了，还想恢复回来，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</span><br><span class="line">git checkout -- test.txt</span><br><span class="line"></span><br><span class="line">git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br></pre></td></tr></table></figure><h4 id="四-远程仓库"><a href="#四-远程仓库" class="headerlink" title="四 远程仓库"></a>四 远程仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本地仓库关联远程仓库</span><br><span class="line"> git remote add origin 远程仓库地址</span><br><span class="line"> 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</span><br><span class="line"> </span><br><span class="line"> 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，</span><br><span class="line"> 还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge 分支名    命令用于合并指定分支到当前分支</span><br><span class="line">合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，</span><br><span class="line">能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">查看分支：git branch</span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h4 id="六、冲突解决"><a href="#六、冲突解决" class="headerlink" title="六、冲突解决"></a>六、冲突解决</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</span><br><span class="line">解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</span><br><span class="line">用git log --graph命令可以看到分支合并图。</span><br></pre></td></tr></table></figure><h4 id="七、"><a href="#七、" class="headerlink" title="七、"></a>七、</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</span><br><span class="line"></span><br><span class="line">2、用git stash list命令看看</span><br><span class="line"></span><br><span class="line">3、一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</span><br><span class="line"></span><br><span class="line">4、另一种方式是用git stash pop，恢复的同时把stash内容也删了</span><br><span class="line"></span><br><span class="line">5、你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令</span><br><span class="line"> git stash apply stash@&#123;0&#125;</span><br><span class="line"> </span><br><span class="line"> Git专门提供了一个gitcherry-pick命令，让我们能复制一个特定的提交到当前分支：</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">1、修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</span><br><span class="line">2、当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</span><br><span class="line">3、在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，</span><br><span class="line">    把bug提交的修改“复制”到当前分支，避免重复劳动。</span><br></pre></td></tr></table></figure><h4 id="八、"><a href="#八、" class="headerlink" title="八、"></a>八、</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发一个新feature，最好新建一个分支；</span><br><span class="line">如果要丢弃一个没有被合并过的分支，可以通过git branch -D 分支名 强行删除。</span><br></pre></td></tr></table></figure><h4 id="九、多人协作"><a href="#九、多人协作" class="headerlink" title="九、多人协作"></a>九、多人协作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要查看远程库的信息，用  git remote  或者，用git remote -v显示更详细的信息：</span><br><span class="line">显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">1、查看远程库信息，使用git remote -v；</span><br><span class="line">2、本地新建的分支如果不推送到远程，对其他人就是不可见的；</span><br><span class="line">3、从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</span><br><span class="line">4、在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，</span><br><span class="line">    本地和远程分支的名称最好一致；</span><br><span class="line">5、建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin&#x2F;branch-name；</span><br><span class="line">6、从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</span><br></pre></td></tr></table></figure><h4 id="十、Rebase"><a href="#十、Rebase" class="headerlink" title="十、Rebase"></a>十、Rebase</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rebase 做了什么操作呢？</span><br><span class="line">首先， git 会把 feature1 分支里面的每个 commit 取消掉；</span><br><span class="line">其次，把上面的操作临时保存成 patch 文件，存在 .git&#x2F;rebase 目录下；</span><br><span class="line">然后，把 feature1 分支更新到最新的 master 分支；</span><br><span class="line">最后，把上面保存的 patch 文件应用到 feature1 分支上；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br><span class="line">这样 git 会继续应用余下的 patch 补丁文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase —abort</span><br><span class="line">可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git知识&quot;&gt;&lt;a href=&quot;#git知识&quot; class=&quot;headerlink&quot; title=&quot;git知识&quot;&gt;&lt;/a&gt;git知识&lt;/h3&gt;&lt;h4 id=&quot;一、版本回退&quot;&gt;&lt;a href=&quot;#一、版本回退&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="git" scheme="http://gtliangming.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://gtliangming.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Mongodb的安装</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc37w0004atnmdq27h1g3/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc37w0004atnmdq27h1g3/</id>
    <published>2020-09-08T08:00:00.000Z</published>
    <updated>2020-09-08T09:09:55.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mongodb的安装"><a href="#Mongodb的安装" class="headerlink" title="Mongodb的安装"></a>Mongodb的安装</h2><blockquote><p><code>MongoDB</code> 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 <code>MongoDB</code> 工作在收集和文件的概念。</p></blockquote><h3 id="一、下载方式"><a href="#一、下载方式" class="headerlink" title="一、下载方式"></a>一、下载方式</h3><p>下载MongoDB有三种方式：(具体版本查看官网)</p><p>（1）手动命令安装</p><p>终端运行：<code>curl http://downloads.mongodb.org/osx/mongodb-osx-x86_64-2.4.6.tgz &gt; mongodb.tgz</code></p><p>（2）采用Homebrew</p><p>更新homebrew ：<code>brew update</code></p><p>安装mongodb ：<code>brew install mongodb</code></p><blockquote><p>想安装最新开发版命令 ：<code>brew install mongodb --devel</code></p></blockquote><p>（3）官网下载安装包。</p><p>官网地址 ：<code>https://www.mongodb.com/try?jmp=nav#community</code></p><h3 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h3><h4 id="1、创建MongoDB数据存放的默认文件夹"><a href="#1、创建MongoDB数据存放的默认文件夹" class="headerlink" title="1、创建MongoDB数据存放的默认文件夹"></a>1、创建MongoDB数据存放的默认文件夹</h4><p>MongoDB数据存放的默认路径为/data/db(即根目录下/data/db)，但该目录的文件夹在你电脑不一定存在，执行以下命令创建(你未必有权限创建，所以加上sudo)</p><p><code>sudo mkdir -p /data/db</code></p><blockquote><p>数据库需要读写数据，如果你没root权限，在根目录下创建的文件夹默认是没有写入权限的，直接启动MongoDB会报错</p></blockquote><p>为此文件夹添加读写权限 : <code>sudo chown -R 用户名 /data/db</code></p><h4 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h4><p>打开终端，输入 <code>open -e .bash_profile</code></p><p>在其中添加 <code>export PATH=$&#123;PATH&#125;:/usr/local/MongoDB/bin</code></p><p>用Command+S保存配置，关闭上面的.bash_profile编辑窗口 </p><p>打开终端 输入<code>source .bash_profile</code> 使刚才的配置生效</p><p>然后在终端输入 <code>mongod -version</code> 可以看到版本信息  说明已经安装成功</p><h4 id="3、使用mongodb"><a href="#3、使用mongodb" class="headerlink" title="3、使用mongodb"></a>3、使用mongodb</h4><p>运行mongodb :终端输入 <code>mongod</code> 启动mongob </p><p>显示等候客户端连接的界面就代表启动成功了，如果不成功就检查下 /data/db 文件夹位置对不对，不行就重新删掉建一个， 打开浏览器，输入localhost:27017 ，会出现这样一行文字。</p><blockquote><p>It looks like you are trying to access MongoDB over HTTP on the native driver port</p></blockquote><p>然后再次在终端输入 <code>mongo</code>   开始进入数据库操作</p><h4 id="4、-退出mongodb"><a href="#4、-退出mongodb" class="headerlink" title="4、 退出mongodb"></a>4、 退出mongodb</h4><p>要停止MongoDB的时候一定要正确的退出，不然下次再次连接数据库会出现问题，使用下面的两行代码可以完成这一操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin;</span><br><span class="line"></span><br><span class="line">db.shutdownServer();</span><br></pre></td></tr></table></figure><h3 id="三、可视化数据库工具"><a href="#三、可视化数据库工具" class="headerlink" title="三、可视化数据库工具"></a>三、可视化数据库工具</h3><p>​    Robo 3t</p><p>RoboMongo是一个跨平台的MongoDB GUI客户端管理工具，支持Windows、MacOS、Linux。其特点是支持到MongoDB服务器的SSL连接，还支持使用SSH隧道连接。RoboMongo的查询界面同时支持树视图、表格视图、文本视图三种，也可以保存查询结果供以后使用。</p><p>下载地址 ：<a href="https://robomongo.org/">https://robomongo.org/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mongodb的安装&quot;&gt;&lt;a href=&quot;#Mongodb的安装&quot; class=&quot;headerlink&quot; title=&quot;Mongodb的安装&quot;&gt;&lt;/a&gt;Mongodb的安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt; 是一个跨</summary>
      
    
    
    
    <category term="mongodb" scheme="http://gtliangming.github.io/categories/mongodb/"/>
    
    
    <category term="mongodb" scheme="http://gtliangming.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>将node.js搭建的express项目如何部署到服务器上</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc386000fatnm2a9aew4v/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc386000fatnm2a9aew4v/</id>
    <published>2020-09-08T07:30:00.000Z</published>
    <updated>2020-09-08T09:11:20.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将node-js搭建的express项目如何部署到服务器上"><a href="#将node-js搭建的express项目如何部署到服务器上" class="headerlink" title="将node.js搭建的express项目如何部署到服务器上"></a>将node.js搭建的express项目如何部署到服务器上</h2><h3 id="1、所用环境"><a href="#1、所用环境" class="headerlink" title="1、所用环境"></a>1、所用环境</h3><ul><li>node.js </li><li>类似于Zen Term Lite（mac上的）的终端模拟软件 (为什么要用这个，稍后讲)</li><li>已经购买好的云服务器（我是阿里云的）</li><li>宝塔环境</li></ul><h3 id="2、开始部署"><a href="#2、开始部署" class="headerlink" title="2、开始部署"></a>2、开始部署</h3><h4 id="1-第一步-配置自己的云服务器"><a href="#1-第一步-配置自己的云服务器" class="headerlink" title="1. 第一步-配置自己的云服务器"></a>1. 第一步-配置自己的云服务器</h4><p>打开控制台，创建实例（此处划重点！！！牢记密码）</p><p>并且需要记一下自己云服务器的公网地址</p><h4 id="2、给自己的云服务器安装宝塔环境（linux系统）"><a href="#2、给自己的云服务器安装宝塔环境（linux系统）" class="headerlink" title="2、给自己的云服务器安装宝塔环境（linux系统）"></a>2、给自己的云服务器安装宝塔环境（linux系统）</h4><p>下载终端模拟软件，我使用的是xShell，还有好几种，在这里不做赘述</p><p><strong>- 什么是终端模拟软件</strong></p><p>可通过互联网到远程主机的安全连接以及它创新性的设计和特色来帮助用户在极其复杂的网络环境当中进行工作与模拟。</p><p><a href="http://www.xshellcn.com/">Xshell</a>可以直接在Windows界面下访问远程端不同系统下的服务器，从而可让用户更好地进行终端的远程控制.</p><p>Zen Term Lite和xShell功能一样</p><p><strong>- 为什么要用终端模拟软件</strong></p><p>！！！实测，在控制台的远程连接，下载东西巨慢巨慢（也可能是我网不好），其实也是界面看起来让我难受：）</p><p><strong>- 怎么使用</strong></p><ul><li>打开你的云服务器控制台，找到防火墙，在防火墙内添加新的规则</li></ul><ul><li><p>选择一个你喜欢的端口（还是百度一下常用的端口，不要占了默认的端口:（ ）</p></li><li><p>打开终端模拟软件，选择新建一个会话,输入信息</p></li></ul><p>  会话名称：随意，你开心</p><p>  主机地址：刚才的公网地址</p><p>  用户名：一般都是root</p><p>  端口：刚才防火墙开放的端口</p><ul><li>点击连接，会让你输入密码，次密码就是你创建实例的时候的实例密码（也可在属性-认证里面配置密码，以后连接就不让你输入了）</li></ul><h4 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h4><p>1、在连接好的终端内输入</p><p><code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</code></p><p>然后回车下载，等一会~，中途会有一次让你确认一次，无脑y就完事了</p><p>2、下载完成后，就可以看到username 和 password了</p><p>其中也包括宝塔的访问地址 http://你的域名或者ip:8888</p><p>此时宝塔就安装好了</p><h3 id="3、打开宝塔，安装pm2"><a href="#3、打开宝塔，安装pm2" class="headerlink" title="3、打开宝塔，安装pm2"></a>3、打开宝塔，安装pm2</h3><ul><li><p>在文件内找到一个合适的文件夹（建议放在www目录下）上传并解压</p></li><li><p>在软件管理里面找到pm2管理器，安装</p></li><li><p>安装完成后点击设置</p></li></ul><p>​            然后点击添加</p><ul><li>在创建好的项目里可以看到端口号，次端口就是你在自己的node项目内设置的端口号</li><li>点击映射可以用域名来映射项目，访问时直接域名+端口号就可以访问，当然也可以不映射，使用ip来访问也是一样的</li><li>在左侧的选项中，你可以选择适合你的node版本，</li><li>也可在模块管理中安装你所需的模块，我这里安装了express和mongoose（项目里用到了）</li></ul><h3 id="4、再次打开终端模拟软件"><a href="#4、再次打开终端模拟软件" class="headerlink" title="4、再次打开终端模拟软件"></a>4、再次打开终端模拟软件</h3><p>使用<code>node -version</code> 和<code>npm --version</code> 查看是否安装好了node和npm</p><p><strong><em>如果没有版本号显示，你就得给服务器安装node，有的话跳过此项</em></strong></p><p>方法</p><p>在终端内输入ls命令，在home下找到一个合适的文件夹 cd进入</p><ul><li><p>输入<code>wget  https://nodejs.org/dist/v10.15.1/node-v10.15.1-linux-x64.tar.xz</code> 并回车，当然版本与操作系统都是可选的，具体的版本请node官网查看</p></li><li><p>下载完成后将tar.xz 解压成 .tar</p><p><code>xz -d node-v10.15.1-linux-x64.tar.xz</code></p><p>此时的安装包已经变为 <code> node-v10.15.1-linux-x64.tar</code></p></li><li><p>解压tar包</p><p><code>tar -xvf node-v10.15.1-linux-x64.tar </code></p><p>解压完成后在当前路径下会出现 <code> node-v10.15.1-linux-x64</code> 文件夹 就成功了</p><p>记得删除无用的包，减少服务器压力</p></li><li><p>查看bin目录下是否有node以及npm文件夹</p><p>cd进入刚才的<code> node-v10.15.1-linux-x64</code> 文件夹下，找到bin文件并查看是否用node与npm</p></li><li><p>有的话执行软连接</p><p>输入命令 </p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s /路径/bin/npm /usr/<span class="built_in">local</span>/bin/ </span><br><span class="line">ln -s /路径/bin/node /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;software&#x2F;node-v10.15.1-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">ln -s &#x2F;software&#x2F;node-v10.15.1-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li>此时再次使用<code>node -version</code> 和<code>npm --version</code> 查看是否安装好了node和npm，显示版本号就算成功</li></ul><h3 id="5、给自己的项目安装依赖"><a href="#5、给自己的项目安装依赖" class="headerlink" title="5、给自己的项目安装依赖"></a>5、给自己的项目安装依赖</h3><p>打开终端模拟软件，使用ls与cd进入到自己的项目文件夹下</p><p>使用 <code> npm install</code> 将package.json的依赖安装完成</p><p>最后使用 <code>pm2 start ./bin/www</code> 用pm2将自己的项目跑起来</p><h4 id="6、配置端口"><a href="#6、配置端口" class="headerlink" title="6、配置端口"></a>6、配置端口</h4><p>打开宝塔，在最左侧找到安全组 开放3000至3500的端口（端口范围3000:3500），点击放行</p><p>再打开你的服务器控制台，在防火墙内添加新的规则，开放3000至3500的端口（端口范围3000/3500）  点击添加</p><h4 id="7、最后一步，重新启动项目"><a href="#7、最后一步，重新启动项目" class="headerlink" title="7、最后一步，重新启动项目"></a>7、最后一步，重新启动项目</h4><p>再次在终端内使用ls+cd到你的项目目录下</p><p>使用 <code> pm2 restart ./bin/www</code>  此时你的node项目就已经部署到服务器上了</p><p>可以使用ip+端口号+你定义的路由 就可以访问你写好的接口了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将node-js搭建的express项目如何部署到服务器上&quot;&gt;&lt;a href=&quot;#将node-js搭建的express项目如何部署到服务器上&quot; class=&quot;headerlink&quot; title=&quot;将node.js搭建的express项目如何部署到服务器上&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="node.js" scheme="http://gtliangming.github.io/categories/node-js/"/>
    
    
    <category term="node.js express 服务器部署" scheme="http://gtliangming.github.io/tags/node-js-express-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>WebPack的配置(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc37z0006atnmhgah1201/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc37z0006atnmhgah1201/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-09-18T10:28:05.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、webpack-config-js"><a href="#一、webpack-config-js" class="headerlink" title="一、webpack.config.js"></a>一、webpack.config.js</h3><h4 id="1、打包模式-mode"><a href="#1、打包模式-mode" class="headerlink" title="1、打包模式 mode"></a>1、打包模式 mode</h4><p>在打包时配置mode是为了告知 webpack 使用相应模式的内置优化</p><p>mode的模式分别有三种：we</p><ul><li>Production   生产环境打包 默认值</li><li>Development  开发环境打包</li><li>None  不使用任何默认优化选项</li></ul><p>Production与Development的区别：</p><ul><li>生产模式会把打包好后的代码进行压缩，可阅读性不好，但是代码体积小</li><li>开发模式不会压缩代码，可阅读性好，但是代码体积大</li><li>开发模式一些没有依赖的方法 变量 文件会保留，生产模式会移除</li></ul><h4 id="2、入口-entry"><a href="#2、入口-entry" class="headerlink" title="2、入口  entry"></a>2、入口  entry</h4><p>入口起点告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的文件内容</p><p><code>entry</code>接受三种形式的值：字符串，数组和对象</p><ul><li><p>对象</p><p>基本形式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entyr:&#123;</span><br><span class="line">&lt;key&gt;:<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 每一个属性对都对应一个入口文件，适合多页面打包配置</span></span><br></pre></td></tr></table></figure></li></ul><p>   <strong>key的值可以为比较简单的字符串，此时key对应出口文件output.filename配置中的[name]变量</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如 </span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;app-entry&#x27;</span>: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的app-entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>key的值也可以为路径字符串，此时webpack会自动生成路径目录，并将路径的最后作为[name]</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;/example/entry&#x27;</span>: <span class="string">&#x27;./deep-app.js&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的example文件夹下的entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>value如果是字符串，那就必须是合理的node require函数参数字符串。</strong></p><p>  <strong>比如文件路径：’./app.js’       (require(‘./app.js’))；</strong></p><p>  <strong>比如安装的npm模块：’lodash’       (require(‘lodash’))</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;my-lodash&#x27;</span>: <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./output&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>value如果是数组，则数组中元素需要是上面描述的合理字符串值。数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    vendor: [<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串</p><p><code>entry: &#39;./app.js&#39;</code>  等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组</p><p><code>entry: [&#39;./index.js&#39;, &#39;lodash&#39;]</code> 等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: [<span class="string">&#x27;./app.js&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、出口-output"><a href="#3、出口-output" class="headerlink" title="3、出口 output"></a>3、出口 output</h4><p>告诉webpack怎样存储输出结果以及存储到哪里,指定每个输出文件的名称。在这里不能指定为绝对路径！</p><p>基本形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">path:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  publicPath:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  filename:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// path:所有输出文件的目标路径;打包后文件在硬盘中的存储位置。</span></span><br><span class="line"><span class="comment">// publicPath:输出解析文件的目录，指定资源文件引用的目录 ，打包后浏览器访问服务时的 url 路径中通用的一部分。</span></span><br></pre></td></tr></table></figure><ul><li><p>Path 仅仅告诉Webpack结果存储在哪里</p></li><li><p>publicPath 用于在生产模式下更新内嵌到css、html文件里的url值</p><p><strong>output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误</strong></p></li></ul><p>注 ：在使用html-webpack-plugin 生成index.html时，publicPath是可以不用配置的。</p><p>​    <strong>output的输出hash值</strong></p><ul><li><p>[hash] </p><p>每个文件的hash都一样，文件的hash为打包的hash。</p></li><li><p>[chunkhash] </p><p>使用文件的hash都不一样，也与打包hash不一样</p></li></ul><h4 id="4、-模块"><a href="#4、-模块" class="headerlink" title="4、 模块"></a>4、 模块</h4><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块。每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p><ul><li><p>配置 Loader</p><p>rules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 <code>rules</code> 时大致通过以下方式：</p><ol><li>条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。</li><li>应用规则：对选中后的文件通过 <code>use</code> 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。</li><li>重置顺序：一组 Loader 的执行顺序默认是从右到左执行，通过 <code>enforce</code> 选项可以让其中一个 Loader 的执行顺序放到最前或者最后</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 css 文件</span></span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 用 babel-loader 转换 css 文件</span></span><br><span class="line">      <span class="comment">// ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度</span></span><br><span class="line">      use: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">      <span class="comment">// 只命中src目录里的js文件，加快 Webpack 搜索速度</span></span><br><span class="line">      include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 SCSS 文件</span></span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 使用一组 Loader 去处理 SCSS 文件。</span></span><br><span class="line">      <span class="comment">// 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。</span></span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">      <span class="comment">// 排除 node_modules 目录下的文件</span></span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 对GIF、PNG等的文件采用 file-loader 加载</span></span><br><span class="line">      test: <span class="regexp">/\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;file-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Loader 需要传入很多参数时，你还可以通过一个 对象 来描述</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      cacheDirectory:<span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// enforce:&#x27;post&#x27; 的含义是把该 Loader 的执行顺序放到最后</span></span><br><span class="line">    <span class="comment">// enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面</span></span><br><span class="line">    enforce:<span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中的test、include、exclude都可以传入数组，数组里的每项之间是或的关系，即文件路径符合数组中的任何一个条件就会被命中</p><ul><li>配置 noParse</li></ul><p><code>noParse</code> 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能。 原因是一些库例如 jQuery 、ChartJS 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p><p><code>noParse</code> 是可选配置项，类型需要是 <code>RegExp</code>、<code>[RegExp]</code>、<code>function</code> 其中一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line">noParse: <span class="regexp">/jquery|chartjs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数，从 Webpack 3.0.0 开始支持</span></span><br><span class="line">noParse: <span class="function">(<span class="params">content</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// content 代表一个模块的文件路径</span></span><br><span class="line">  <span class="comment">// 返回 true or false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/jquery|chartjs/</span>.test(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。</span></span><br></pre></td></tr></table></figure><ul><li>配置 parser</li></ul><p>因为 Webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能，支持 AMD、CommonJS、SystemJS、ES6。 <code>parser</code> 属性可以更细粒度的配置哪些模块语法要解析哪些不解析，和 <code>noParse</code> 配置项的区别在于 <code>parser</code> 可以精确到语法层面， 而 noParse 只能控制哪些文件不被解析。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;style&quot;</span>, <span class="string">&quot;css&quot;</span>, <span class="string">&quot;postcss&quot;</span>],</span><br><span class="line">      parser: &#123;</span><br><span class="line">        amd: <span class="literal">false</span>, <span class="comment">// 禁用 AMD</span></span><br><span class="line">        commonjs: <span class="literal">false</span>, <span class="comment">// 禁用 CommonJS</span></span><br><span class="line">        system: <span class="literal">false</span>, <span class="comment">// 禁用 SystemJS</span></span><br><span class="line">        harmony: <span class="literal">false</span>, <span class="comment">// 禁用 ES6 import/export</span></span><br><span class="line">        requireInclude: <span class="literal">false</span>, <span class="comment">// 禁用 require.include</span></span><br><span class="line">        requireEnsure: <span class="literal">false</span>, <span class="comment">// 禁用 require.ensure</span></span><br><span class="line">        requireContext: <span class="literal">false</span>, <span class="comment">// 禁用 require.context</span></span><br><span class="line">        browserify: <span class="literal">false</span>, <span class="comment">// 禁用 browserify</span></span><br><span class="line">        requireJs: <span class="literal">false</span>, <span class="comment">// 禁用 requirejs</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、webpack-config-js&quot;&gt;&lt;a href=&quot;#一、webpack-config-js&quot; class=&quot;headerlink&quot; title=&quot;一、webpack.config.js&quot;&gt;&lt;/a&gt;一、webpack.config.js&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>WebPack的配置(一)</title>
    <link href="http://gtliangming.github.io/2020/09/08/ckg7rc382000aatnm3eay71vv/"/>
    <id>http://gtliangming.github.io/2020/09/08/ckg7rc382000aatnm3eay71vv/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-09-09T05:59:31.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、webpack-config-js"><a href="#一、webpack-config-js" class="headerlink" title="一、webpack.config.js"></a>一、webpack.config.js</h3><h4 id="1、打包模式-mode"><a href="#1、打包模式-mode" class="headerlink" title="1、打包模式 mode"></a>1、打包模式 mode</h4><p>在打包时配置mode是为了告知 webpack 使用相应模式的内置优化</p><p>mode的模式分别有三种：we</p><ul><li>Production   生产环境打包 默认值</li><li>Development  开发环境打包</li><li>None  不使用任何默认优化选项</li></ul><p>Production与Development的区别：</p><ul><li>生产模式会把打包好后的代码进行压缩，可阅读性不好，但是代码体积小</li><li>开发模式不会压缩代码，可阅读性好，但是代码体积大</li><li>开发模式一些没有依赖的方法 变量 文件会保留，生产模式会移除</li></ul><h4 id="2、入口-entry"><a href="#2、入口-entry" class="headerlink" title="2、入口  entry"></a>2、入口  entry</h4><p>入口起点告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的文件内容</p><p><code>entry</code>接受三种形式的值：字符串，数组和对象</p><ul><li><p>对象</p><p>基本形式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entyr:&#123;</span><br><span class="line">&lt;key&gt;:<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 每一个属性对都对应一个入口文件，适合多页面打包配置</span></span><br></pre></td></tr></table></figure></li></ul><p>   <strong>key的值可以为比较简单的字符串，此时key对应出口文件output.filename配置中的[name]变量</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如 </span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;app-entry&#x27;</span>: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的app-entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>key的值也可以为路径字符串，此时webpack会自动生成路径目录，并将路径的最后作为[name]</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;/example/entry&#x27;</span>: <span class="string">&#x27;./deep-app.js&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 则对./app.js打包完成后生成的文件是在dist文件夹下的example文件夹下的entry.js文件</span></span><br></pre></td></tr></table></figure><p>  <strong>value如果是字符串，那就必须是合理的node require函数参数字符串。</strong></p><p>  <strong>比如文件路径：’./app.js’       (require(‘./app.js’))；</strong></p><p>  <strong>比如安装的npm模块：’lodash’       (require(‘lodash’))</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">&#x27;my-lodash&#x27;</span>: <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">&#x27;./output&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>value如果是数组，则数组中元素需要是上面描述的合理字符串值。数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    vendor: [<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串</p><p><code>entry: &#39;./app.js&#39;</code>  等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组</p><p><code>entry: [&#39;./index.js&#39;, &#39;lodash&#39;]</code> 等价于下面的对象形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: [<span class="string">&#x27;./app.js&#x27;</span>, <span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、出口-output"><a href="#3、出口-output" class="headerlink" title="3、出口 output"></a>3、出口 output</h4><p>告诉webpack怎样存储输出结果以及存储到哪里,指定每个输出文件的名称。在这里不能指定为绝对路径！</p><p>基本形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">path:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  publicPath:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  filename:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// path:所有输出文件的目标路径;打包后文件在硬盘中的存储位置。</span></span><br><span class="line"><span class="comment">// publicPath:输出解析文件的目录，指定资源文件引用的目录 ，打包后浏览器访问服务时的 url 路径中通用的一部分。</span></span><br></pre></td></tr></table></figure><ul><li><p>Path 仅仅告诉Webpack结果存储在哪里</p></li><li><p>publicPath 用于在生产模式下更新内嵌到css、html文件里的url值</p><p><strong>output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误</strong></p></li></ul><p>注 ：在使用html-webpack-plugin 生成index.html时，publicPath是可以不用配置的。</p><p>​    <strong>output的输出hash值</strong></p><ul><li><p>[hash] </p><p>每个文件的hash都一样，文件的hash为打包的hash。</p></li><li><p>[chunkhash] </p><p>使用文件的hash都不一样，也与打包hash不一样</p></li></ul><h4 id="4、-模块"><a href="#4、-模块" class="headerlink" title="4、 模块"></a>4、 模块</h4><p>在模块化编程中，开发者将程序分解成离散功能块，并称之为模块。每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p><ul><li><p>配置 Loader</p><p>rules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 <code>rules</code> 时大致通过以下方式：</p><ol><li>条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。</li><li>应用规则：对选中后的文件通过 <code>use</code> 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。</li><li>重置顺序：一组 Loader 的执行顺序默认是从右到左执行，通过 <code>enforce</code> 选项可以让其中一个 Loader 的执行顺序放到最前或者最后</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 css 文件</span></span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 用 babel-loader 转换 css 文件</span></span><br><span class="line">      <span class="comment">// ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度</span></span><br><span class="line">      use: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">      <span class="comment">// 只命中src目录里的js文件，加快 Webpack 搜索速度</span></span><br><span class="line">      include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命中 SCSS 文件</span></span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 使用一组 Loader 去处理 SCSS 文件。</span></span><br><span class="line">      <span class="comment">// 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。</span></span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">      <span class="comment">// 排除 node_modules 目录下的文件</span></span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 对GIF、PNG等的文件采用 file-loader 加载</span></span><br><span class="line">      test: <span class="regexp">/\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;file-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Loader 需要传入很多参数时，你还可以通过一个 对象 来描述</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">      cacheDirectory:<span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// enforce:&#x27;post&#x27; 的含义是把该 Loader 的执行顺序放到最后</span></span><br><span class="line">    <span class="comment">// enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面</span></span><br><span class="line">    enforce:<span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中的test、include、exclude都可以传入数组，数组里的每项之间是或的关系，即文件路径符合数组中的任何一个条件就会被命中</p><ul><li>配置 noParse</li></ul><p><code>noParse</code> 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能。 原因是一些库例如 jQuery 、ChartJS 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p><p><code>noParse</code> 是可选配置项，类型需要是 <code>RegExp</code>、<code>[RegExp]</code>、<code>function</code> 其中一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line">noParse: <span class="regexp">/jquery|chartjs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数，从 Webpack 3.0.0 开始支持</span></span><br><span class="line">noParse: <span class="function">(<span class="params">content</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// content 代表一个模块的文件路径</span></span><br><span class="line">  <span class="comment">// 返回 true or false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/jquery|chartjs/</span>.test(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。</span></span><br></pre></td></tr></table></figure><ul><li>配置 parser</li></ul><p>因为 Webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能，支持 AMD、CommonJS、SystemJS、ES6。 <code>parser</code> 属性可以更细粒度的配置哪些模块语法要解析哪些不解析，和 <code>noParse</code> 配置项的区别在于 <code>parser</code> 可以精确到语法层面， 而 noParse 只能控制哪些文件不被解析。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;style&quot;</span>, <span class="string">&quot;css&quot;</span>, <span class="string">&quot;postcss&quot;</span>],</span><br><span class="line">      parser: &#123;</span><br><span class="line">        amd: <span class="literal">false</span>, <span class="comment">// 禁用 AMD</span></span><br><span class="line">        commonjs: <span class="literal">false</span>, <span class="comment">// 禁用 CommonJS</span></span><br><span class="line">        system: <span class="literal">false</span>, <span class="comment">// 禁用 SystemJS</span></span><br><span class="line">        harmony: <span class="literal">false</span>, <span class="comment">// 禁用 ES6 import/export</span></span><br><span class="line">        requireInclude: <span class="literal">false</span>, <span class="comment">// 禁用 require.include</span></span><br><span class="line">        requireEnsure: <span class="literal">false</span>, <span class="comment">// 禁用 require.ensure</span></span><br><span class="line">        requireContext: <span class="literal">false</span>, <span class="comment">// 禁用 require.context</span></span><br><span class="line">        browserify: <span class="literal">false</span>, <span class="comment">// 禁用 browserify</span></span><br><span class="line">        requireJs: <span class="literal">false</span>, <span class="comment">// 禁用 requirejs</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、webpack-config-js&quot;&gt;&lt;a href=&quot;#一、webpack-config-js&quot; class=&quot;headerlink&quot; title=&quot;一、webpack.config.js&quot;&gt;&lt;/a&gt;一、webpack.config.js&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    
    <category term="WebPack" scheme="http://gtliangming.github.io/tags/WebPack/"/>
    
  </entry>
  
</feed>
